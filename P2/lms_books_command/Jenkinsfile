pipeline {
    agent any

    environment {
        // Maven e Java
        MAVEN_HOME = '/usr/share/maven'
        JAVA_HOME  = '/usr/lib/jvm/java-17-openjdk-amd64'

        // Git
        GIT_REPO_URL   = 'https://github.com/tiagomiguel55/lms-library.git'
        GIT_BRANCH    = 'main'
        CREDENTIALS_ID = 'password_for_github_tiago'

        // Docker Registry (configure according to your registry)
        DOCKER_REGISTRY = 'docker.io'  // Use 'docker.io' for Docker Hub, or your private registry URL
        DOCKER_REGISTRY_CREDENTIALS = 'dockerhub-credentials'  // Jenkins credential ID for Docker registry
        DOCKER_REGISTRY_NAMESPACE = 'tiagomiguel55'  // Your Docker Hub username or registry namespace

        // Docker
        IMAGE_NAME = 'lmsbooks'
        IMAGE_TAG  = "${GIT_COMMIT}" // imagem imut√°vel por commit SHA
        FULL_IMAGE_NAME = "${DOCKER_REGISTRY}/${DOCKER_REGISTRY_NAMESPACE}/${IMAGE_NAME}"

        // Swarm stacks
        STACK_NAME_DEV     = 'lmsbooks-dev'
        STACK_NAME_STAGING = 'lmsbooks-staging'
        STACK_NAME_PROD    = 'lmsbooks-prod'

        // Blue/Green Deployment
        STACK_NAME_PROD_BLUE  = 'lmsbooks-prod-blue'
        STACK_NAME_PROD_GREEN = 'lmsbooks-prod-green'
        BLUE_PORT  = '8083'
        GREEN_PORT = '8084'
        LIVE_ENV_FILE = '/tmp/lmsbooks_live_env.txt'

        // Email
        EMAIL_RECIPIENT = 'migueltiago255@gmail.com'

        // Working directory
        WORK_DIR = 'P2/lms_books_command'
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Deployment environment'
        )
        choice(
            name: 'DEPLOYMENT_STRATEGY',
            choices: ['blue-green', 'rolling'],
            description: 'Deployment strategy for production (only applies to prod environment)'
        )
        booleanParam(
            name: 'SKIP_DEPLOY',
            defaultValue: false,
            description: 'Skip deployment'
        )
        booleanParam(
            name: 'FORCE_ROLLBACK',
            defaultValue: false,
            description: 'Force rollback to previous environment (Blue/Green only)'
        )
    }

    stages {

        stage('Checkout') {
            steps {
                git branch: "${GIT_BRANCH}",
                    url: "${GIT_REPO_URL}",
                    credentialsId: "${CREDENTIALS_ID}"
            }
        }

        stage('Build & Package') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Build apenas em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        ${MAVEN_HOME}/bin/mvn clean package -DskipTests
                    """
                }
            }
        }

        stage('Build Docker Image') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Build apenas em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
                        docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${params.ENVIRONMENT}
                    """
                }
            }
        }

        stage('Push Docker Image to Registry') {
            when {
                expression { params.ENVIRONMENT == 'dev' || params.ENVIRONMENT == 'staging' }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pushing image to registry..."
                            echo "Environment: ${params.ENVIRONMENT}"
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Namespace: ${DOCKER_REGISTRY_NAMESPACE}"
                            echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Tagging for registry..."
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "Pushing image..."
                            docker push ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker push ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Image pushed to registry!"
                            echo "   ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Pull Docker Image from Registry') {
            when {
                expression { params.ENVIRONMENT == 'prod' } // Prod faz pull da imagem de staging
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pulling image from registry for Production..."
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Image: ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Pulling image..."
                            docker pull ${FULL_IMAGE_NAME}:${IMAGE_TAG}

                            echo ""
                            echo "Tagging as prod and local name..."
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "Pushing prod tag to registry..."
                            docker push ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Production image ready!"
                            echo "   Local: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   Registry: ${FULL_IMAGE_NAME}:prod"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Initialize Docker Swarm') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh '''
                    docker info | grep -q "Swarm: active" || docker swarm init || true

                    # Create lms_network (shared network for all environments)
                    docker network ls --format "{{.Name}}" | grep -qx lms_network || \
                    docker network create --driver overlay --attachable lms_network || true

                    # Create lms_network_prod (for Blue/Green production deployments)
                    docker network ls --format "{{.Name}}" | grep -qx lms_network_prod || \
                    docker network create --driver overlay --attachable lms_network_prod || true

                    echo "Networks created:"
                    docker network ls | grep lms_network
                '''
            }
        }

        stage('Deploy Shared RabbitMQ Infrastructure') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh """
                    echo "=========================================="
                    echo "Deploying Shared RabbitMQ Infrastructure"
                    echo "Environment: ${params.ENVIRONMENT}"
                    echo "=========================================="

                    ENVIRONMENT="${params.ENVIRONMENT}"
                    STACK_NAME="lms_shared_\${ENVIRONMENT}"

                    # Define environment-specific ports
                    case "\${ENVIRONMENT}" in
                        dev)
                            RABBITMQ_PORT=5672
                            RABBITMQ_MGMT_PORT=15672
                            VOLUME_NAME="rabbitmq_data_dev"
                            ;;
                        staging)
                            RABBITMQ_PORT=5673
                            RABBITMQ_MGMT_PORT=15673
                            VOLUME_NAME="rabbitmq_data_staging"
                            ;;
                        prod)
                            RABBITMQ_PORT=5674
                            RABBITMQ_MGMT_PORT=15674
                            VOLUME_NAME="rabbitmq_data_prod"
                            ;;
                        *)
                            echo "‚ùå ERROR: Unknown environment: \${ENVIRONMENT}"
                            exit 1
                            ;;
                    esac

                    echo "Environment: \${ENVIRONMENT}"
                    echo "Stack Name: \${STACK_NAME}"
                    echo "RabbitMQ Port: \${RABBITMQ_PORT}"
                    echo "RabbitMQ Management Port: \${RABBITMQ_MGMT_PORT}"
                    echo "Volume Name: \${VOLUME_NAME}"
                    echo ""

                    # Generate environment-specific docker-compose file
                    COMPOSE_FILE="${WORKSPACE}/docker-compose-rabbitmq-\${ENVIRONMENT}-generated.yml"

                    cat > "\${COMPOSE_FILE}" <<EOF
version: '3.8'

services:
  lms_shared_rabbitmq:
    image: rabbitmq:3-management
    restart: unless-stopped
    ports:
      - "\${RABBITMQ_PORT}:5672"
      - "\${RABBITMQ_MGMT_PORT}:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    volumes:
      - \${VOLUME_NAME}:/var/lib/rabbitmq
    networks:
      - lms_network
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 10s
      retries: 5
      timeout: 5s

networks:
  lms_network:
    external: true

volumes:
  \${VOLUME_NAME}:
EOF

                    echo "‚úÖ Generated compose file: \${COMPOSE_FILE}"
                    echo ""
                    echo "Content:"
                    cat "\${COMPOSE_FILE}"
                    echo ""

                    # Check if lms_shared stack already exists
                    if docker stack ls | grep -q "\${STACK_NAME}"; then
                        echo "‚úÖ \${STACK_NAME} stack already deployed"
                        echo ""
                        echo "Current RabbitMQ service status:"
                        docker service ls --filter "name=\${STACK_NAME}" || echo "RabbitMQ service found"

                        echo ""
                        echo "Updating existing stack with new configuration..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 15 seconds for update to stabilize..."
                        sleep 15
                    else
                        echo "Deploying \${STACK_NAME} stack with RabbitMQ..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 30 seconds for RabbitMQ to start..."
                        sleep 30

                        echo ""
                        echo "Verifying RabbitMQ deployment:"
                        docker service ls --filter "name=\${STACK_NAME}"
                    fi

                    echo ""
                    echo "RabbitMQ service full name:"
                    docker service ls | grep "\${STACK_NAME}" || echo "No RabbitMQ found for \${STACK_NAME}"

                    echo ""
                    echo "RabbitMQ service details:"
                    docker service ps "\${STACK_NAME}_lms_shared_rabbitmq" --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "Service is starting..."

                    echo ""
                    echo "=========================================="
                    echo "‚úÖ RabbitMQ Infrastructure deployed for \${ENVIRONMENT}"
                    echo "   - Internal port: 5672 (for applications)"
                    echo "   - External port: \${RABBITMQ_PORT}"
                    echo "   - Management UI: http://localhost:\${RABBITMQ_MGMT_PORT}"
                    echo "   - Service name: \${STACK_NAME}_lms_shared_rabbitmq"
                    echo "   - DNS hostname: lms_shared_rabbitmq"
                    echo "=========================================="
                """
            }
        }

        stage('Deploy to Dev') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'dev' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm.yml ${STACK_NAME_DEV}

                        echo ""
                        echo "=========================================="
                        echo "VERIFYING RABBITMQ SERVICE"
                        echo "=========================================="

                        echo "Waiting for services to stabilize..."
                        sleep 15

                        # List all services
                        echo "All services:"
                        docker service ls

                        echo ""
                        echo "Looking for RabbitMQ service..."
                        docker service ls | grep rabbitmq || echo "No RabbitMQ service found!"

                        echo ""
                        echo "Checking if RabbitMQ service from dev stack exists:"
                        docker service inspect ${STACK_NAME_DEV}_rabbitmq_dev 2>/dev/null && echo "‚úÖ RabbitMQ service exists" || echo "‚ùå RabbitMQ service NOT FOUND"

                        echo ""
                        echo "RabbitMQ service details:"
                        docker service ps ${STACK_NAME_DEV}_rabbitmq_dev --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "Could not get RabbitMQ status"

                        echo "=========================================="
                    """
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm-staging.yml ${STACK_NAME_STAGING}
                    """
                }
            }
        }

        stage('Deploy Shared PostgreSQL (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        echo "=========================================="
                        echo "DEPLOYING SHARED INFRASTRUCTURE FOR BLUE/GREEN"
                        echo "=========================================="

                        # Create lms_network_prod if it doesn't exist
                        echo "Ensuring lms_network_prod exists..."
                        docker network ls | grep -q lms_network_prod || \
                        docker network create --driver overlay --attachable lms_network_prod || true

                        echo ""
                        echo "Network status:"
                        docker network ls | grep lms_network

                        # Deploy Traefik Load Balancer
                        echo ""
                        echo "=========================================="
                        echo "DEPLOYING TRAEFIK LOAD BALANCER"
                        echo "=========================================="

                        if docker stack ls | grep -q "lmsbooks-prod-traefik"; then
                            echo "‚úÖ Traefik already deployed - updating..."
                        else
                            echo "üì¶ Deploying Traefik for the first time..."
                        fi

                        docker stack deploy -c docker-compose-swarm-prod-traefik.yml lmsbooks-prod-traefik

                        echo "Waiting for Traefik to be ready..."
                        sleep 15

                        TRAEFIK_SERVICE=\$(docker service ls --filter "name=lmsbooks-prod-traefik_traefik" --format "{{.Name}}" || echo "")
                        if [ -n "\$TRAEFIK_SERVICE" ]; then
                            echo "‚úÖ Traefik service: \$TRAEFIK_SERVICE"
                            docker service ps \$TRAEFIK_SERVICE --format "  {{.Name}}: {{.CurrentState}}" | head -3
                        fi

                        echo ""
                        echo "‚úÖ Traefik deployed successfully!"
                        echo "   - Load Balancer Port: 8080 (main entry point)"
                        echo "   - Dashboard: http://localhost:8090/dashboard/"
                        echo ""

                        # Deploy PostgreSQL
                        echo "=========================================="
                        echo "DEPLOYING SHARED POSTGRESQL"
                        echo "=========================================="

                        # Check if PostgreSQL stack already exists
                        if docker stack ls | grep -q "lmsbooks-prod-postgres"; then
                            echo ""
                            echo "‚úÖ PostgreSQL stack already exists - updating..."
                        else
                            echo ""
                            echo "üì¶ Creating new PostgreSQL stack..."
                        fi

                        # Deploy shared PostgreSQL
                        docker stack deploy -c docker-compose-swarm-prod-postgres.yml lmsbooks-prod-postgres

                        echo ""
                        echo "Waiting for PostgreSQL to be ready..."
                        sleep 20

                        # Verify PostgreSQL is running
                        PG_SERVICE=\$(docker service ls --filter "name=lmsbooks-prod-postgres_postgres_command_prod" --format "{{.Name}}" || echo "")

                        if [ -n "\$PG_SERVICE" ]; then
                            echo "‚úÖ PostgreSQL service: \$PG_SERVICE"
                            docker service ps \$PG_SERVICE --format "  {{.Name}}: {{.CurrentState}}"

                            # Wait for PostgreSQL to be healthy
                            echo ""
                            echo "Waiting for PostgreSQL to become healthy..."
                            MAX_WAIT=60
                            ELAPSED=0
                            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                REPLICAS=\$(docker service ls --filter "name=\$PG_SERVICE" --format "{{.Replicas}}")
                                echo "PostgreSQL status: \$REPLICAS (elapsed: \${ELAPSED}s)"

                                if echo "\$REPLICAS" | grep -q "1/1"; then
                                    echo "‚úÖ PostgreSQL is ready!"
                                    break
                                fi

                                sleep 5
                                ELAPSED=\$((ELAPSED + 5))
                            done
                        else
                            echo "‚ùå ERROR: PostgreSQL service not found!"
                            exit 1
                        fi

                        echo ""
                        echo "=========================================="
                        echo "‚úÖ Shared Infrastructure Ready!"
                        echo "=========================================="
                        echo "Traefik Load Balancer:"
                        echo "   - Main Entry: http://localhost:8080"
                        echo "   - Dashboard: http://localhost:8090/dashboard/"
                        echo ""
                        echo "PostgreSQL Database:"
                        echo "   - Service: lmsbooks-prod-postgres_postgres_command_prod"
                        echo "   - Database: lmsbooks_prod"
                        echo "   - Port: 5434 (external), 5432 (internal)"
                        echo "=========================================="
                    """
                }
            }
        }

        stage('Manual Approval for Production') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                script {
                    def strategyInfo = params.DEPLOYMENT_STRATEGY == 'blue-green' ?
                        "Blue/Green Deployment (Zero-downtime with instant rollback)" :
                        "Rolling Update (Gradual update with automatic rollback)"

                    echo "=========================================="
                    echo "PRODUCTION DEPLOYMENT APPROVAL REQUIRED"
                    echo "=========================================="
                    echo "Project: LMS Books Command Service"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Image Tag: ${IMAGE_TAG}"
                    echo "Environment: PRODUCTION"
                    echo "Deployment Strategy: ${params.DEPLOYMENT_STRATEGY.toUpperCase()}"
                    echo ""
                    if (params.DEPLOYMENT_STRATEGY == 'blue-green') {
                        echo "Blue/Green Strategy:"
                        echo "  - Deploy to inactive environment"
                        echo "  - Run health checks on new environment"
                        echo "  - Switch traffic instantly"
                        echo "  - Keep old environment for instant rollback"
                    } else {
                        echo "Rolling Update Strategy:"
                        echo "  - Update 1 container at a time"
                        echo "  - 10-second delay between updates"
                        echo "  - Health checks before proceeding"
                        echo "  - Automatic rollback on failure"
                    }
                    echo "=========================================="

                    // Try to send email notification
                    try {
                        mail(
                            to: "${EMAIL_RECIPIENT}",
                            subject: "Jenkins: Production Deployment Approval Required - Build #${BUILD_NUMBER}",
                            body: """
                                Production Deployment Approval Required
                                =======================================

                                Project: LMS Books Command Service
                                Build Number: ${BUILD_NUMBER}
                                Image Tag: ${IMAGE_TAG}
                                Environment: PRODUCTION
                                Deployment Strategy: ${params.DEPLOYMENT_STRATEGY.toUpperCase()}

                                ${strategyInfo}

                                Please review and approve/reject the deployment to production.

                                Approve or reject at: ${BUILD_URL}input/

                                View full build details: ${BUILD_URL}
                            """,
                            mimeType: 'text/plain'
                        )
                        echo "‚úÖ Email notification sent successfully to ${EMAIL_RECIPIENT}"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è WARNING: Could not send email notification"
                        echo "Email error: ${e.message}"
                        echo "Continuing with manual approval process..."
                    }

                    timeout(time: 30, unit: 'MINUTES') {
                        input message: 'Approve Production Deployment?', ok: 'Deploy'
                    }
                }
            }
        }

        stage('Determine Active Environment (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                script {
                    sh """
                        echo "=========================================="
                        echo "BLUE/GREEN DEPLOYMENT - ENVIRONMENT CHECK"
                        echo "=========================================="

                        # Check which environment is currently active
                        BLUE_RUNNING=\$(docker service ls --filter "name=${STACK_NAME_PROD_BLUE}_lmsbooks_command_blue" --format "{{.Replicas}}" 2>/dev/null | grep -v "0/0" | head -1 || echo "")
                        GREEN_RUNNING=\$(docker service ls --filter "name=${STACK_NAME_PROD_GREEN}_lmsbooks_command_green" --format "{{.Replicas}}" 2>/dev/null | grep -v "0/0" | head -1 || echo "")

                        echo "Blue environment status: \${BLUE_RUNNING:-not deployed}"
                        echo "Green environment status: \${GREEN_RUNNING:-not deployed}"

                        # Read current live environment from file (if exists)
                        if [ -f "${LIVE_ENV_FILE}" ]; then
                            CURRENT_LIVE=\$(cat ${LIVE_ENV_FILE})
                            echo "Current live environment (from file): \$CURRENT_LIVE"
                        else
                            CURRENT_LIVE=""
                            echo "No live environment file found - first deployment"
                        fi

                        # Determine which environment to deploy to
                        if [ "\$CURRENT_LIVE" = "blue" ]; then
                            TARGET_ENV="green"
                            INACTIVE_ENV="blue"
                        elif [ "\$CURRENT_LIVE" = "green" ]; then
                            TARGET_ENV="blue"
                            INACTIVE_ENV="green"
                        elif [ -n "\$BLUE_RUNNING" ] && [ -z "\$GREEN_RUNNING" ]; then
                            # Blue is running, deploy to green
                            TARGET_ENV="green"
                            INACTIVE_ENV="blue"
                            echo "blue" > ${LIVE_ENV_FILE}
                        elif [ -n "\$GREEN_RUNNING" ] && [ -z "\$BLUE_RUNNING" ]; then
                            # Green is running, deploy to blue
                            TARGET_ENV="blue"
                            INACTIVE_ENV="green"
                            echo "green" > ${LIVE_ENV_FILE}
                        else
                            # First deployment - start with blue
                            TARGET_ENV="blue"
                            INACTIVE_ENV=""
                            echo "First deployment - deploying to blue environment"
                        fi

                        echo ""
                        echo "=========================================="
                        echo "Deployment Plan:"
                        echo "  - Current Live: \${CURRENT_LIVE:-none}"
                        echo "  - Target Environment: \$TARGET_ENV"
                        echo "  - Will become inactive: \${INACTIVE_ENV:-none}"
                        echo "=========================================="

                        # Save target environment for next stages
                        echo "\$TARGET_ENV" > /tmp/lmsbooks_target_env.txt
                        echo "\${INACTIVE_ENV:-none}" > /tmp/lmsbooks_inactive_env.txt
                    """

                    // Read target environment into pipeline variable
                    env.TARGET_ENV = sh(script: "cat /tmp/lmsbooks_target_env.txt", returnStdout: true).trim()
                    env.INACTIVE_ENV = sh(script: "cat /tmp/lmsbooks_inactive_env.txt", returnStdout: true).trim()

                    echo "Target environment for deployment: ${env.TARGET_ENV}"
                }
            }
        }

        stage('Deploy to Inactive Environment (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        def targetEnv = env.TARGET_ENV
                        def stackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN
                        def composeFile = targetEnv == 'blue' ? 'docker-compose-swarm-prod-blue.yml' : 'docker-compose-swarm-prod-green.yml'
                        def port = targetEnv == 'blue' ? env.BLUE_PORT : env.GREEN_PORT

                        echo "=========================================="
                        echo "DEPLOYING TO ${targetEnv.toUpperCase()} ENVIRONMENT"
                        echo "=========================================="
                        echo "Stack: ${stackName}"
                        echo "Compose File: ${composeFile}"
                        echo "Port: ${port}"
                        echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"

                        sh """
                            export IMAGE_TAG=${IMAGE_TAG}

                            echo ""
                            echo "Deploying ${targetEnv} environment..."
                            docker stack deploy -c ${composeFile} ${stackName}

                            echo ""
                            echo "Waiting for ${targetEnv} environment to start..."
                            sleep 30

                            # Get service name
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}" | grep lmsbooks | head -1)

                            if [ -z "\$SERVICE_NAME" ]; then
                                echo "‚ùå ERROR: Service was not created!"
                                exit 1
                            fi

                            echo "Service name: \$SERVICE_NAME"

                            # Wait for replicas to be ready
                            EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                            echo "Expected replicas: \$EXPECTED_REPLICAS"

                            MAX_WAIT=180
                            ELAPSED=0

                            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")
                                echo "Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS (elapsed: \${ELAPSED}s)"

                                if [ "\$RUNNING_REPLICAS" -ge "\$EXPECTED_REPLICAS" ]; then
                                    echo "‚úÖ All replicas are running!"
                                    break
                                fi

                                sleep 10
                                ELAPSED=\$((ELAPSED + 10))
                            done

                            if [ "\$RUNNING_REPLICAS" -lt "\$EXPECTED_REPLICAS" ]; then
                                echo "‚ùå Not all replicas started in time"
                                docker service logs --tail 50 \$SERVICE_NAME || true
                                exit 1
                            fi

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ ${targetEnv.toUpperCase()} environment deployed successfully!"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Health Check New Environment (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                script {
                    def targetEnv = env.TARGET_ENV
                    def stackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN
                    def port = targetEnv == 'blue' ? env.BLUE_PORT : env.GREEN_PORT

                    echo "=========================================="
                    echo "HEALTH CHECK - ${targetEnv.toUpperCase()} ENVIRONMENT"
                    echo "=========================================="

                    sh """
                        echo "Waiting for health checks to stabilize..."
                        sleep 30

                        # Get service name
                        SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}" | grep lmsbooks | head -1)

                        echo "Checking health of service: \$SERVICE_NAME"
                        echo ""

                        # Get expected replicas
                        EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                        echo "Expected replicas: \$EXPECTED_REPLICAS"
                        echo ""

                        # Check service health and show detailed status
                        echo "Replica Status Details:"
                        echo "----------------------------------------"
                        docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "No tasks found"

                        echo ""
                        TASKS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)
                        HEALTHY_COUNT=0
                        TOTAL_COUNT=0
                        RUNNING_COUNT=0

                        for TASK in \$TASKS; do
                            TOTAL_COUNT=\$((TOTAL_COUNT + 1))
                            CONTAINER_ID=\$(docker inspect \$TASK --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")
                            TASK_NAME=\$(docker inspect \$TASK --format "{{.Name}}" 2>/dev/null)
                            TASK_STATE=\$(docker inspect \$TASK --format "{{.Status.State}}" 2>/dev/null || echo "unknown")

                            if [ -n "\$CONTAINER_ID" ]; then
                                HEALTH=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "none")

                                # Count as running if task state is "running"
                                if [ "\$TASK_STATE" = "running" ]; then
                                    RUNNING_COUNT=\$((RUNNING_COUNT + 1))
                                fi

                                if [ "\$HEALTH" = "healthy" ]; then
                                    echo "  ‚úÖ \$TASK_NAME: HEALTHY (state: \$TASK_STATE)"
                                    HEALTHY_COUNT=\$((HEALTHY_COUNT + 1))
                                elif [ "\$HEALTH" = "starting" ]; then
                                    echo "  üîÑ \$TASK_NAME: STARTING (state: \$TASK_STATE)"
                                    # Give it more time
                                    sleep 30
                                    HEALTH=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "none")
                                    TASK_STATE=\$(docker inspect \$TASK --format "{{.Status.State}}" 2>/dev/null || echo "unknown")
                                    if [ "\$HEALTH" = "healthy" ]; then
                                        echo "  ‚úÖ \$TASK_NAME: NOW HEALTHY (state: \$TASK_STATE)"
                                        HEALTHY_COUNT=\$((HEALTHY_COUNT + 1))
                                        if [ "\$TASK_STATE" = "running" ]; then
                                            RUNNING_COUNT=\$((RUNNING_COUNT + 1))
                                        fi
                                    fi
                                else
                                    echo "  ‚ÑπÔ∏è  \$TASK_NAME: \${HEALTH} (state: \$TASK_STATE)"
                                    # If task is running but health check not configured, count it
                                    if [ "\$TASK_STATE" = "running" ] && [ "\$HEALTH" = "none" ]; then
                                        echo "      (No health check configured - counting as healthy based on running state)"
                                        HEALTHY_COUNT=\$((HEALTHY_COUNT + 1))
                                    fi
                                fi
                            else
                                echo "  ‚ö†Ô∏è  \$TASK_NAME: Container not yet available (state: \$TASK_STATE)"
                            fi
                        done

                        echo ""
                        echo "Summary:"
                        echo "  Total tasks: \$TOTAL_COUNT"
                        echo "  Running tasks: \$RUNNING_COUNT"
                        echo "  Healthy/Ready tasks: \$HEALTHY_COUNT"
                        echo "  Expected replicas: \$EXPECTED_REPLICAS"

                        # Consider deployment successful if we have the expected number of running replicas
                        # Health checks might still be starting, which is acceptable
                        if [ "\$RUNNING_COUNT" -ge "\$EXPECTED_REPLICAS" ]; then
                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Health check PASSED!"
                            echo "   All \$RUNNING_COUNT/\$EXPECTED_REPLICAS replicas are running"
                            if [ "\$HEALTHY_COUNT" -lt "\$EXPECTED_REPLICAS" ]; then
                                echo "   ‚ö†Ô∏è  Note: Some health checks still initializing (this is normal)"
                            fi
                            echo "=========================================="
                        else
                            echo ""
                            echo "=========================================="
                            echo "‚ùå Health check FAILED!"
                            echo "   Only \$RUNNING_COUNT/\$EXPECTED_REPLICAS replicas running"
                            echo ""
                            echo "Detailed task information:"
                            docker service ps \$SERVICE_NAME --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" --no-trunc
                            echo ""
                            echo "Service logs (last 50 lines):"
                            docker service logs --tail 50 \$SERVICE_NAME || true
                            echo "=========================================="
                            exit 1
                        fi
                    """
                }
            }
        }

        stage('Switch Traffic (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        def targetEnv = env.TARGET_ENV
                        def inactiveEnv = env.INACTIVE_ENV
                        def targetStackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN
                        def inactiveStackName = inactiveEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN

                        echo "=========================================="
                        echo "SWITCHING TRAFFIC TO ${targetEnv.toUpperCase()} (TRAEFIK)"
                        echo "=========================================="

                        sh """
                            echo "New live environment: ${targetEnv}"
                            echo "Previous live: ${inactiveEnv}"

                            # Determine priorities
                            if [ "${targetEnv}" = "blue" ]; then
                                NEW_BLUE_PRIORITY=100
                                NEW_GREEN_PRIORITY=1
                            else
                                NEW_BLUE_PRIORITY=1
                                NEW_GREEN_PRIORITY=100
                            fi

                            echo ""
                            echo "Setting Traefik routing priorities..."
                            echo "Blue priority: \$NEW_BLUE_PRIORITY"
                            echo "Green priority: \$NEW_GREEN_PRIORITY"

                            # Get service names
                            BLUE_SERVICE=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD_BLUE}" --format "{{.Name}}" | grep lmsbooks | head -1)
                            GREEN_SERVICE=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD_GREEN}" --format "{{.Name}}" | grep lmsbooks | head -1)

                            # Get current images to show in output
                            if [ -n "\$BLUE_SERVICE" ]; then
                                BLUE_IMAGE=\$(docker service inspect \$BLUE_SERVICE --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Blue current image: \$BLUE_IMAGE"
                            fi

                            if [ -n "\$GREEN_SERVICE" ]; then
                                GREEN_IMAGE=\$(docker service inspect \$GREEN_SERVICE --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Green current image: \$GREEN_IMAGE"
                            fi

                            # Update priorities via docker service update (preserves images)
                            echo ""
                            echo "Updating service priorities (without changing images)..."

                            # Update Blue service priority
                            if [ -n "\$BLUE_SERVICE" ]; then
                                echo "Updating Blue priority to \$NEW_BLUE_PRIORITY..."
                                docker service update \\
                                    --label-add "traefik.http.routers.lmsbooks-blue.priority=\$NEW_BLUE_PRIORITY" \\
                                    \$BLUE_SERVICE
                            fi

                            # Update Green service priority
                            if [ -n "\$GREEN_SERVICE" ]; then
                                echo "Updating Green priority to \$NEW_GREEN_PRIORITY..."
                                docker service update \\
                                    --label-add "traefik.http.routers.lmsbooks-green.priority=\$NEW_GREEN_PRIORITY" \\
                                    \$GREEN_SERVICE
                            fi

                            # Update the live environment file
                            echo "${targetEnv}" > ${LIVE_ENV_FILE}

                            echo ""
                            echo "Waiting 10 seconds for Traefik to update routing..."
                            sleep 10

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Traffic switched to ${targetEnv.toUpperCase()} via Traefik!"
                            echo "=========================================="
                            echo "Traefik Load Balancer:"
                            echo "  - Main Entry: http://74.161.33.56:8085"
                            echo "  - Dashboard: http://74.161.33.56:8090/dashboard/"
                            echo ""
                            echo "Live Environment: ${targetEnv.toUpperCase()}"
                            echo "  - Stack: ${targetStackName}"
                            echo "  - Priority: \$NEW_BLUE_PRIORITY (if blue) or \$NEW_GREEN_PRIORITY (if green)"
                            echo "  - Image: \$([ "${targetEnv}" = "blue" ] && echo "\$BLUE_IMAGE" || echo "\$GREEN_IMAGE")"
                            echo ""
                            echo "Standby Environment: ${inactiveEnv.toUpperCase()}"
                            echo "  - Stack: ${inactiveStackName}"
                            echo "  - Priority: \$([ "${inactiveEnv}" = "blue" ] && echo "\$NEW_BLUE_PRIORITY" || echo "\$NEW_GREEN_PRIORITY")"
                            echo "  - Image: \$([ "${inactiveEnv}" = "blue" ] && echo "\$BLUE_IMAGE" || echo "\$GREEN_IMAGE")"
                            echo ""
                            echo "‚ö†Ô∏è  NOTE: Both environments remain running with PRESERVED images for instant rollback"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Rollback (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.FORCE_ROLLBACK == true }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "ROLLBACK REQUESTED"
                        echo "=========================================="

                        sh """
                            # Read current live environment
                            if [ -f "${LIVE_ENV_FILE}" ]; then
                                CURRENT_LIVE=\$(cat ${LIVE_ENV_FILE})
                            else
                                echo "‚ùå ERROR: No live environment file found!"
                                echo "Cannot determine which environment to rollback to."
                                exit 1
                            fi

                            # Determine rollback target
                            if [ "\$CURRENT_LIVE" = "blue" ]; then
                                ROLLBACK_TO="green"
                                ROLLBACK_STACK="${STACK_NAME_PROD_GREEN}"
                                ROLLBACK_PORT="${GREEN_PORT}"
                                # Set priorities: Green becomes active (100), Blue becomes standby (1)
                                NEW_BLUE_PRIORITY=1
                                NEW_GREEN_PRIORITY=100
                            else
                                ROLLBACK_TO="blue"
                                ROLLBACK_STACK="${STACK_NAME_PROD_BLUE}"
                                ROLLBACK_PORT="${BLUE_PORT}"
                                # Set priorities: Blue becomes active (100), Green becomes standby (1)
                                NEW_BLUE_PRIORITY=100
                                NEW_GREEN_PRIORITY=1
                            fi

                            echo "Current live: \$CURRENT_LIVE"
                            echo "Rolling back to: \$ROLLBACK_TO"

                            # Check if rollback target exists
                            ROLLBACK_SERVICE=\$(docker service ls --filter "label=com.docker.stack.namespace=\$ROLLBACK_STACK" --format "{{.Name}}" | grep lmsbooks | head -1 || echo "")

                            if [ -z "\$ROLLBACK_SERVICE" ]; then
                                echo "‚ùå ERROR: Rollback environment (\$ROLLBACK_TO) is not deployed!"
                                echo "Cannot rollback - no previous version available."
                                exit 1
                            fi

                            # Get current image tags from both services to preserve them
                            echo ""
                            echo "Getting current image versions..."

                            BLUE_SERVICE=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD_BLUE}" --format "{{.Name}}" | grep lmsbooks | head -1)
                            GREEN_SERVICE=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD_GREEN}" --format "{{.Name}}" | grep lmsbooks | head -1)

                            if [ -n "\$BLUE_SERVICE" ]; then
                                BLUE_IMAGE=\$(docker service inspect \$BLUE_SERVICE --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Blue current image: \$BLUE_IMAGE"
                            fi

                            if [ -n "\$GREEN_SERVICE" ]; then
                                GREEN_IMAGE=\$(docker service inspect \$GREEN_SERVICE --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Green current image: \$GREEN_IMAGE"
                            fi

                            # Update labels via service update (only changes priorities, keeps images)
                            echo ""
                            echo "=========================================="
                            echo "SWITCHING TRAFFIC VIA TRAEFIK PRIORITIES"
                            echo "=========================================="
                            echo "New Blue priority: \$NEW_BLUE_PRIORITY"
                            echo "New Green priority: \$NEW_GREEN_PRIORITY"
                            echo ""

                            # Update Blue service priority (keep existing image)
                            if [ -n "\$BLUE_SERVICE" ]; then
                                echo "Updating Blue priority to \$NEW_BLUE_PRIORITY..."
                                docker service update \\
                                    --label-add "traefik.http.routers.lmsbooks-blue.priority=\$NEW_BLUE_PRIORITY" \\
                                    \$BLUE_SERVICE
                            fi

                            # Update Green service priority (keep existing image)
                            if [ -n "\$GREEN_SERVICE" ]; then
                                echo "Updating Green priority to \$NEW_GREEN_PRIORITY..."
                                docker service update \\
                                    --label-add "traefik.http.routers.lmsbooks-green.priority=\$NEW_GREEN_PRIORITY" \\
                                    \$GREEN_SERVICE
                            fi

                            # Update the live environment file
                            echo "\$ROLLBACK_TO" > ${LIVE_ENV_FILE}

                            echo ""
                            echo "Waiting 10 seconds for Traefik to update routing..."
                            sleep 10

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ ROLLBACK COMPLETED!"
                            echo "=========================================="
                            echo "Traffic switched to: \$ROLLBACK_TO"
                            echo "Port: \$ROLLBACK_PORT (via Traefik on 8085)"
                            echo "Stack: \$ROLLBACK_STACK"
                            echo ""
                            echo "Current state:"
                            echo "  Blue - Priority: \$NEW_BLUE_PRIORITY, Image: \${BLUE_IMAGE:-N/A}"
                            echo "  Green - Priority: \$NEW_GREEN_PRIORITY, Image: \${GREEN_IMAGE:-N/A}"
                            echo ""
                            echo "‚ö†Ô∏è  IMPORTANT: Image versions were preserved during rollback"
                            echo "Access the service at: http://74.161.33.56:8085"
                            echo "Traefik Dashboard: http://74.161.33.56:8090/dashboard/"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Deploy to Production (Rolling Update + Rollback)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'rolling' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "Starting PROD rolling update with image ${IMAGE_NAME}:${IMAGE_TAG}"

                        sh """
                            # Check if service already exists
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_command" --format "{{.Name}}" 2>/dev/null || echo "")

                            if [ -z "\$SERVICE_NAME" ]; then
                                echo "=========================================="
                                echo "‚ö†Ô∏è Service does not exist yet - First deployment"
                                echo "Creating stack for the first time..."
                                echo "=========================================="

                                # First deployment - just create the stack
                                export IMAGE_TAG=${IMAGE_TAG}
                                docker stack deploy -c docker-compose-swarm-prod.yml ${STACK_NAME_PROD}

                                echo "Waiting for services to start..."
                                sleep 30

                                # Get the newly created service name
                                SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_command" --format "{{.Name}}")

                                if [ -z "\$SERVICE_NAME" ]; then
                                    echo "‚ùå ERROR: Service was not created!"
                                    exit 1
                                fi

                                # Check if all replicas are running
                                EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                                echo "Expected replicas: \$EXPECTED_REPLICAS"

                                MAX_WAIT=180
                                ELAPSED=0

                                while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                    RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running")
                                    echo "Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS (elapsed: \${ELAPSED}s)"

                                    if [ \$RUNNING_REPLICAS -ge \$EXPECTED_REPLICAS ]; then
                                        echo "‚úÖ All replicas are running - first deployment successful!"
                                        break
                                    fi

                                    sleep 10
                                    ELAPSED=\$((ELAPSED + 10))
                                done

                                if [ \$RUNNING_REPLICAS -lt \$EXPECTED_REPLICAS ]; then
                                    echo "‚ùå Not all replicas started in time"
                                    docker service logs --tail 50 \$SERVICE_NAME || true
                                    exit 1
                                fi

                            else
                                echo "=========================================="
                                echo "‚úì Service exists - Performing Rolling Update"
                                echo "Service name: \$SERVICE_NAME"
                                echo "=========================================="

                                # Save old image for rollback
                                OLD_IMAGE=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Old image: \$OLD_IMAGE"
                                echo "New image: ${IMAGE_NAME}:${IMAGE_TAG}"

                                # Deploy new image with rolling update
                                export IMAGE_TAG=${IMAGE_TAG}
                                docker stack deploy -c docker-compose-swarm-prod.yml ${STACK_NAME_PROD}

                                echo "Docker Swarm is performing rolling update..."
                                echo "Monitoring service update progress..."

                                # Wait for deployment to start
                                sleep 20

                                # Get expected replicas
                                EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                                echo "Expected replicas: \$EXPECTED_REPLICAS"

                                # Monitor rolling update
                                MAX_WAIT=300
                                ELAPSED=0
                                UPDATE_COMPLETE=false

                                while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                    STATUS=\$(docker service inspect \$SERVICE_NAME --format '{{.UpdateStatus.State}}' 2>/dev/null || echo "")
                                    RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")

                                    echo "Update status: \${STATUS:-none} | Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS | Elapsed: \${ELAPSED}s"

                                    # Check if update completed
                                    if [ "\$STATUS" = "completed" ]; then
                                        echo "‚úÖ Rolling update completed successfully!"
                                        UPDATE_COMPLETE=true
                                        break
                                    # Check if all replicas are running (even if status is unknown)
                                    elif [ \$RUNNING_REPLICAS -ge \$EXPECTED_REPLICAS ] && [ \$ELAPSED -gt 30 ]; then
                                        echo "‚úÖ All replicas running - deployment successful!"
                                        UPDATE_COMPLETE=true
                                        break
                                    # Check for failures
                                    elif [ "\$STATUS" = "rollback_completed" ]; then
                                        echo "‚ùå Swarm automatic rollback completed!"
                                        echo "Checking service logs..."
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        exit 1
                                    elif [ "\$STATUS" = "paused" ]; then
                                        echo "‚ùå Update paused - rolling back manually to \$OLD_IMAGE..."
                                        docker service update --image \$OLD_IMAGE \$SERVICE_NAME
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        exit 1
                                    fi

                                    # Show current replicas status
                                    docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" 2>/dev/null || true

                                    sleep 10
                                    ELAPSED=\$((ELAPSED + 10))
                                done

                                # Handle timeout
                                if [ "\$UPDATE_COMPLETE" = "false" ]; then
                                    echo "‚ö†Ô∏è Rolling update timed out. Checking final status..."
                                    FINAL_RUNNING=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")

                                    if [ \$FINAL_RUNNING -ge \$EXPECTED_REPLICAS ]; then
                                        echo "‚úÖ All replicas confirmed running - deployment successful!"
                                        UPDATE_COMPLETE=true
                                    else
                                        echo "‚ùå Not all replicas running. Rolling back to \$OLD_IMAGE..."
                                        docker service update --image \$OLD_IMAGE \$SERVICE_NAME
                                        echo "Waiting for rollback to complete..."
                                        sleep 20
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        docker service ps \$SERVICE_NAME || true
                                        exit 1
                                    fi
                                fi
                            fi

                            echo "=========================================="
                            echo "Production deployment completed successfully!"
                            echo "All replicas running version ${IMAGE_TAG}"
                            echo "=========================================="

                            # Final status
                            docker stack services ${STACK_NAME_PROD}
                            docker stack ps ${STACK_NAME_PROD}

                            # Health Check Status
                            echo ""
                            echo "=========================================="
                            echo "HEALTH CHECK STATUS - PRODUCTION"
                            echo "=========================================="

                            # Get service name
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_command" --format "{{.Name}}")

                            if [ -n "\$SERVICE_NAME" ]; then
                                echo ""
                                echo "Service: \$SERVICE_NAME"
                                echo "----------------------------------------"

                                # Get all task IDs for the service
                                TASK_IDS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)

                                for TASK_ID in \$TASK_IDS; do
                                    # Get container ID from task
                                    CONTAINER_ID=\$(docker inspect \$TASK_ID --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")

                                    if [ -n "\$CONTAINER_ID" ]; then
                                        echo ""
                                        echo "Task: \$TASK_ID"
                                        HEALTH_STATUS=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "no healthcheck")

                                        if [ "\$HEALTH_STATUS" != "no healthcheck" ]; then
                                            echo "  Health Status: \$HEALTH_STATUS"

                                            # Get last health check log
                                            LAST_CHECK=\$(docker inspect \$CONTAINER_ID --format "{{range .State.Health.Log}}{{.End}} - {{.ExitCode}} - {{.Output}}{{end}}" 2>/dev/null | tail -1 || echo "N/A")
                                            echo "  Last Check: \$LAST_CHECK"
                                        else
                                            echo "  Health Status: Not configured or starting"
                                        fi

                                        # Show replica state
                                        REPLICA_STATE=\$(docker service ps \$SERVICE_NAME --filter "id=\$TASK_ID" --format "{{.CurrentState}}" 2>/dev/null)
                                        echo "  Replica State: \$REPLICA_STATE"
                                    fi
                                done

                                echo ""
                                echo "----------------------------------------"
                                echo "Health Check Configuration:"
                                docker service inspect \$SERVICE_NAME --format "{{json .Spec.TaskTemplate.ContainerSpec.Healthcheck}}" 2>/dev/null | python3 -m json.tool 2>/dev/null || echo "  Configured in docker-compose file"
                            fi

                            # Check health of all services in the stack
                            echo ""
                            echo "=========================================="
                            echo "ALL SERVICES HEALTH STATUS"
                            echo "=========================================="
                            docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

                            echo ""
                            echo "Detailed service inspection:"
                            for SERVICE in \$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --format "{{.Name}}"); do
                                echo ""
                                echo "Service: \$SERVICE"
                                docker service ps \$SERVICE --format "  {{.Name}}: {{.CurrentState}}" | head -5
                            done

                            echo ""
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Post-Deployment Verification') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                script {
                    // Determine correct stack name based on deployment strategy and environment
                    def stackName

                    if (params.ENVIRONMENT == 'prod' && params.DEPLOYMENT_STRATEGY == 'blue-green') {
                        // For Blue/Green, verify the target environment that was just deployed
                        def targetEnv = env.TARGET_ENV ?: 'blue'
                        stackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN

                        echo "=========================================="
                        echo "POST-DEPLOYMENT VERIFICATION (BLUE/GREEN)"
                        echo "Environment: ${params.ENVIRONMENT}"
                        echo "Deployment Strategy: Blue/Green"
                        echo "Active Environment: ${targetEnv}"
                        echo "Stack Name: ${stackName}"
                        echo "=========================================="
                    } else {
                        // For dev, staging, or rolling update
                        stackName = params.ENVIRONMENT == 'dev' ? env.STACK_NAME_DEV :
                                   (params.ENVIRONMENT == 'staging' ? env.STACK_NAME_STAGING : env.STACK_NAME_PROD)

                        echo "=========================================="
                        echo "POST-DEPLOYMENT VERIFICATION"
                        echo "Environment: ${params.ENVIRONMENT}"
                        echo "Stack Name: ${stackName}"
                        echo "=========================================="
                    }

                    sh """
                        # Wait for Docker Swarm to update replica status
                        echo ""
                        echo "Waiting 15 seconds for Docker Swarm to update replica status..."
                        sleep 15

                        echo ""
                        echo "Current service status:"
                        docker stack services ${stackName} || echo "‚ö†Ô∏è Stack ${stackName} may not exist yet"

                        echo ""
                        echo "Service tasks:"
                        docker stack ps ${stackName} --no-trunc || echo "‚ö†Ô∏è No tasks found for stack ${stackName}"

                        echo ""
                        echo "=========================================="
                    """

                    // Show health checks for production only
                    if (params.ENVIRONMENT == 'prod') {
                        // For Blue/Green, show both environments if they exist
                        if (params.DEPLOYMENT_STRATEGY == 'blue-green') {
                            sh """
                                echo ""
                                echo "=========================================="
                                echo "BLUE/GREEN ENVIRONMENT STATUS"
                                echo "=========================================="

                                echo ""
                                echo "BLUE Environment (${env.STACK_NAME_PROD_BLUE}):"
                                echo "----------------------------------------"
                                docker service ls --filter "label=com.docker.stack.namespace=${env.STACK_NAME_PROD_BLUE}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}" 2>/dev/null || echo "Not deployed"

                                echo ""
                                echo "GREEN Environment (${env.STACK_NAME_PROD_GREEN}):"
                                echo "----------------------------------------"
                                docker service ls --filter "label=com.docker.stack.namespace=${env.STACK_NAME_PROD_GREEN}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}" 2>/dev/null || echo "Not deployed"

                                echo ""
                                echo "Current Live Environment:"
                                if [ -f "${env.LIVE_ENV_FILE}" ]; then
                                    LIVE=\$(cat ${env.LIVE_ENV_FILE})
                                    # Convert to uppercase using tr instead of bash-specific syntax
                                    LIVE_UPPER=\$(echo "\$LIVE" | tr '[:lower:]' '[:upper:]')
                                    echo "  ‚úÖ \${LIVE_UPPER} is LIVE"

                                    if [ "\$LIVE" = "blue" ]; then
                                        echo "  üìç Access at: http://localhost:${env.BLUE_PORT}"
                                    else
                                        echo "  üìç Access at: http://localhost:${env.GREEN_PORT}"
                                    fi
                                else
                                    echo "  ‚ö†Ô∏è Live environment file not found"
                                fi
                                echo "=========================================="
                            """
                        }

                        sh """
                            echo ""
                            echo "=========================================="
                            echo "POST-DEPLOYMENT HEALTH CHECK VERIFICATION"
                            echo "=========================================="

                            # Wait a bit for health checks to stabilize
                            echo "Waiting 30 seconds for health checks to stabilize..."
                            sleep 30

                            # Check each service
                            for SERVICE in \$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}"); do
                                echo ""
                                echo "Checking health of: \$SERVICE"
                                echo "----------------------------------------"

                                # Get task IDs
                                TASKS=\$(docker service ps \$SERVICE --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)

                                for TASK in \$TASKS; do
                                    CONTAINER_ID=\$(docker inspect \$TASK --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")

                                    if [ -n "\$CONTAINER_ID" ]; then
                                        HEALTH=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "none")
                                        TASK_NAME=\$(docker inspect \$TASK --format "{{.Name}}" 2>/dev/null)

                                        if [ "\$HEALTH" = "healthy" ]; then
                                            echo "  ‚úÖ \$TASK_NAME: HEALTHY"
                                        elif [ "\$HEALTH" = "unhealthy" ]; then
                                            echo "  ‚ùå \$TASK_NAME: UNHEALTHY"
                                        elif [ "\$HEALTH" = "starting" ]; then
                                            echo "  üîÑ \$TASK_NAME: STARTING (health checks in progress)"
                                        else
                                            echo "  ‚ÑπÔ∏è  \$TASK_NAME: No health check configured"
                                        fi
                                    fi
                                done
                            done

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Post-deployment verification completed"
                            echo "=========================================="
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                echo "=========================================="
                echo "Pipeline completed successfully!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "SUCCESS: LMS Books Command - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Successful</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Image Tag:</strong> ${IMAGE_TAG}</p>
                            <p><strong>Status:</strong> ‚úÖ SUCCESS</p>
                            <br>
                            <p><a href="${BUILD_URL}">View Build Details</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "‚úÖ Success notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "‚ö†Ô∏è WARNING: Could not send success email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }

        failure {
            script {
                echo "=========================================="
                echo "Pipeline failed!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "FAILURE: LMS Books Command - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Failed</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Status:</strong> ‚ùå FAILURE</p>
                            <br>
                            <p><a href="${BUILD_URL}console">View Console Output</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "‚úÖ Failure notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "‚ö†Ô∏è WARNING: Could not send failure email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }
    }
}

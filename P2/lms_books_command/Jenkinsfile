pipeline {
    agent any

    environment {
        // Maven e Java
        MAVEN_HOME = '/usr/share/maven'
        JAVA_HOME  = '/usr/lib/jvm/java-17-openjdk-amd64'

        // Git
        GIT_REPO_URL   = 'https://github.com/tiagomiguel55/lms-library.git'
        GIT_BRANCH    = 'main'
        CREDENTIALS_ID = 'password_for_github_tiago'

        // Docker Registry (configure according to your registry)
        DOCKER_REGISTRY = 'docker.io'  // Use 'docker.io' for Docker Hub, or your private registry URL
        DOCKER_REGISTRY_CREDENTIALS = 'dockerhub-credentials'  // Jenkins credential ID for Docker registry
        DOCKER_REGISTRY_NAMESPACE = 'tiagomiguel55'  // Your Docker Hub username or registry namespace

        // Docker
        IMAGE_NAME = 'lmsbooks'
        IMAGE_TAG  = "${GIT_COMMIT}" // imagem imutÃ¡vel por commit SHA
        FULL_IMAGE_NAME = "${DOCKER_REGISTRY}/${DOCKER_REGISTRY_NAMESPACE}/${IMAGE_NAME}"

        // Swarm stacks
        STACK_NAME_DEV     = 'lmsbooks-dev'
        STACK_NAME_STAGING = 'lmsbooks-staging'
        STACK_NAME_PROD    = 'lmsbooks-prod'


        // Blue/Green Deployment - Production
        STACK_NAME_PROD_BLUE  = 'lmsbooks-prod-blue'
        STACK_NAME_PROD_GREEN = 'lmsbooks-prod-green'
        BLUE_PORT  = '8083'
        GREEN_PORT = '8084'
        LIVE_ENV_FILE = '/tmp/lmsbooks_live_env.txt'
        BLUE_IMAGE_FILE = '/tmp/lmsbooks_blue_image.txt'
        GREEN_IMAGE_FILE = '/tmp/lmsbooks_green_image.txt'

        // Email
        EMAIL_RECIPIENT = 'migueltiago255@gmail.com'

        // Working directory
        WORK_DIR = 'P2/lms_books_command'
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Deployment environment'
        )
        choice(
            name: 'DEPLOYMENT_STRATEGY',
            choices: ['blue-green', 'rolling'],
            description: 'Deployment strategy for production (only applies to prod environment)'
        )
        booleanParam(
            name: 'SKIP_DEPLOY',
            defaultValue: false,
            description: 'Skip deployment'
        )
    }

    stages {

        stage('Checkout') {
            steps {
                git branch: "${GIT_BRANCH}",
                    url: "${GIT_REPO_URL}",
                    credentialsId: "${CREDENTIALS_ID}"
            }
        }

        stage('Compile') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Compile apenas em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        ${MAVEN_HOME}/bin/mvn clean compile test-compile
                    """
                }
            }
        }

       stage('Unit Tests') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Testes apenas em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -f DockerfileTests -t ${IMAGE_NAME}-tests:unit .
                        docker run --rm -e TEST_TYPE=unit ${IMAGE_NAME}-tests:unit
                    """
                }
            }
            post {
                success {
                    echo "âœ… Unit Tests passed!"
                }
                failure {
                    echo "âŒ Unit Tests failed!"
                }
            }
        }

        stage('Smoke Tests') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Smoke tests em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -f DockerfileTests -t ${IMAGE_NAME}-tests:smoke .
                        docker run --rm -e TEST_TYPE=smokeTests ${IMAGE_NAME}-tests:smoke
                    """
                }
            }
            post {
                success {
                    echo "âœ… Smoke Tests passed!"
                }
                failure {
                    echo "âŒ Smoke Tests failed!"
                }
            }
        }

        stage('CDC Tests') {
            when {
                expression { params.ENVIRONMENT == 'staging' } // CDC tests apenas em staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -f DockerfileTests -t ${IMAGE_NAME}-tests:cdc .
                        docker run --rm -e TEST_TYPE=CDCTests ${IMAGE_NAME}-tests:cdc
                    """
                }
            }
            post {
                success {
                    echo "âœ… CDC Tests passed!"
                }
                failure {
                    echo "âŒ CDC Tests failed!"
                }
            }
        }

        stage('Mutation Tests') {
            when {
                expression { params.ENVIRONMENT == 'staging' } // Mutation tests apenas em staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -f DockerfileTests -t ${IMAGE_NAME}-tests:mutation .
                        docker run --rm -e TEST_TYPE=mutation ${IMAGE_NAME}-tests:mutation
                    """
                }
            }
            post {
                success {
                    echo "âœ… Mutation Tests passed!"
                }
                failure {
                    echo "âŒ Mutation Tests failed!"
                }
            }
        }

        stage('Build & Package') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Package apenas em dev/staging DEPOIS dos testes
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        ${MAVEN_HOME}/bin/mvn package -DskipTests
                    """
                }
            }
        }

        stage('Build Docker Image') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Build apenas em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
                        docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${params.ENVIRONMENT}
                    """
                }
            }
        }

        stage('Push Docker Image to Registry') {
            when {
                expression { params.ENVIRONMENT == 'dev' || params.ENVIRONMENT == 'staging' }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pushing image to registry..."
                            echo "Environment: ${params.ENVIRONMENT}"
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Namespace: ${DOCKER_REGISTRY_NAMESPACE}"
                            echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Tagging for registry..."
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "Pushing image..."
                            docker push ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker push ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "=========================================="
                            echo "âœ… Image pushed to registry!"
                            echo "   ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Pull Docker Image from Registry') {
            when {
                expression { params.ENVIRONMENT == 'prod' } // Prod faz pull da imagem de staging
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pulling image from registry for Production..."
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Image: ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Pulling image..."
                            docker pull ${FULL_IMAGE_NAME}:${IMAGE_TAG}

                            echo ""
                            echo "Tagging as prod and local name..."
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "Pushing prod tag to registry..."
                            docker push ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "=========================================="
                            echo "âœ… Production image ready!"
                            echo "   Local: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   Registry: ${FULL_IMAGE_NAME}:prod"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Initialize Docker Swarm') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh '''
                    docker info | grep -q "Swarm: active" || docker swarm init || true

                    # Create lms_network (shared network for all environments)
                    docker network ls --format "{{.Name}}" | grep -qx lms_network || \
                    docker network create --driver overlay --attachable lms_network || true

                    # Create lms_network_prod (for Blue/Green production deployments)
                    docker network ls --format "{{.Name}}" | grep -qx lms_network_prod || \
                    docker network create --driver overlay --attachable lms_network_prod || true

                    echo "Networks created:"
                    docker network ls | grep lms_network
                '''
            }
        }

        stage('Deploy Shared RabbitMQ Infrastructure') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh """
                    echo "=========================================="
                    echo "Deploying Shared RabbitMQ Infrastructure"
                    echo "Environment: ${params.ENVIRONMENT}"
                    echo "=========================================="

                    ENVIRONMENT="${params.ENVIRONMENT}"
                    STACK_NAME="lms_shared_\${ENVIRONMENT}"

                    # Define environment-specific ports
                    case "\${ENVIRONMENT}" in
                        dev)
                            RABBITMQ_PORT=5672
                            RABBITMQ_MGMT_PORT=15672
                            VOLUME_NAME="rabbitmq_data_dev"
                            ;;
                        staging)
                            RABBITMQ_PORT=5673
                            RABBITMQ_MGMT_PORT=15673
                            VOLUME_NAME="rabbitmq_data_staging"
                            ;;
                        prod)
                            RABBITMQ_PORT=5674
                            RABBITMQ_MGMT_PORT=15674
                            VOLUME_NAME="rabbitmq_data_prod"
                            ;;
                        *)
                            echo "âŒ ERROR: Unknown environment: \${ENVIRONMENT}"
                            exit 1
                            ;;
                    esac

                    echo "Environment: \${ENVIRONMENT}"
                    echo "Stack Name: \${STACK_NAME}"
                    echo "RabbitMQ Port: \${RABBITMQ_PORT}"
                    echo "RabbitMQ Management Port: \${RABBITMQ_MGMT_PORT}"
                    echo "Volume Name: \${VOLUME_NAME}"
                    echo ""

                    # Generate environment-specific docker-compose file
                    COMPOSE_FILE="${WORKSPACE}/docker-compose-rabbitmq-\${ENVIRONMENT}-generated.yml"

                    cat > "\${COMPOSE_FILE}" <<EOF
version: '3.8'

services:
  lms_shared_rabbitmq:
    image: rabbitmq:3-management
    restart: unless-stopped
    ports:
      - "\${RABBITMQ_PORT}:5672"
      - "\${RABBITMQ_MGMT_PORT}:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    volumes:
      - \${VOLUME_NAME}:/var/lib/rabbitmq
    networks:
      - lms_network
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 10s
      retries: 5
      timeout: 5s

networks:
  lms_network:
    external: true

volumes:
  \${VOLUME_NAME}:
EOF

                    echo "âœ… Generated compose file: \${COMPOSE_FILE}"
                    echo ""
                    echo "Content:"
                    cat "\${COMPOSE_FILE}"
                    echo ""

                    # Check if lms_shared stack already exists
                    if docker stack ls | grep -q "\${STACK_NAME}"; then
                        echo "âœ… \${STACK_NAME} stack already deployed"
                        echo ""
                        echo "Current RabbitMQ service status:"
                        docker service ls --filter "name=\${STACK_NAME}" || echo "RabbitMQ service found"

                        echo ""
                        echo "Updating existing stack with new configuration..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 15 seconds for update to stabilize..."
                        sleep 15
                    else
                        echo "Deploying \${STACK_NAME} stack with RabbitMQ..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 30 seconds for RabbitMQ to start..."
                        sleep 30

                        echo ""
                        echo "Verifying RabbitMQ deployment:"
                        docker service ls --filter "name=\${STACK_NAME}"
                    fi

                    echo ""
                    echo "RabbitMQ service full name:"
                    docker service ls | grep "\${STACK_NAME}" || echo "No RabbitMQ found for \${STACK_NAME}"

                    echo ""
                    echo "RabbitMQ service details:"
                    docker service ps "\${STACK_NAME}_lms_shared_rabbitmq" --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "Service is starting..."

                    echo ""
                    echo "=========================================="
                    echo "âœ… RabbitMQ Infrastructure deployed for \${ENVIRONMENT}"
                    echo "   - Internal port: 5672 (for applications)"
                    echo "   - External port: \${RABBITMQ_PORT}"
                    echo "   - Management UI: http://localhost:\${RABBITMQ_MGMT_PORT}"
                    echo "   - Service name: \${STACK_NAME}_lms_shared_rabbitmq"
                    echo "   - DNS hostname: lms_shared_rabbitmq"
                    echo "=========================================="
                """
            }
        }

        stage('Deploy to Dev') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'dev' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm.yml ${STACK_NAME_DEV}

                        echo ""
                        echo "=========================================="
                        echo "VERIFYING RABBITMQ SERVICE"
                        echo "=========================================="

                        echo "Waiting for services to stabilize..."
                        sleep 15

                        # List all services
                        echo "All services:"
                        docker service ls

                        echo ""
                        echo "Looking for RabbitMQ service..."
                        docker service ls | grep rabbitmq || echo "No RabbitMQ service found!"

                        echo ""
                        echo "Checking if RabbitMQ service from dev stack exists:"
                        docker service inspect ${STACK_NAME_DEV}_rabbitmq_dev 2>/dev/null && echo "âœ… RabbitMQ service exists" || echo "âŒ RabbitMQ service NOT FOUND"

                        echo ""
                        echo "RabbitMQ service details:"
                        docker service ps ${STACK_NAME_DEV}_rabbitmq_dev --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "Could not get RabbitMQ status"

                        echo "=========================================="
                    """
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm-staging.yml ${STACK_NAME_STAGING}

                        echo ""
                        echo "=========================================="
                        echo "VERIFYING RABBITMQ SERVICE"
                        echo "=========================================="

                        echo "Waiting for services to stabilize..."
                        sleep 15

                        # List all services
                        echo "All services:"
                        docker service ls

                        echo ""
                        echo "Looking for RabbitMQ service..."
                        docker service ls | grep rabbitmq || echo "No RabbitMQ service found!"

                        echo ""
                        echo "Checking if RabbitMQ service from staging stack exists:"
                        docker service inspect ${STACK_NAME_STAGING}_rabbitmq_staging 2>/dev/null && echo "âœ… RabbitMQ service exists" || echo "âŒ RabbitMQ service NOT FOUND"

                        echo ""
                        echo "RabbitMQ service details:"
                        docker service ps ${STACK_NAME_STAGING}_rabbitmq_staging --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "Could not get RabbitMQ status"

                        echo "=========================================="
                    """
                }
            }
        }

        stage('Load Tests - K6 (Staging)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "K6 LOAD TESTS - STAGING ENVIRONMENT"
                        echo "=========================================="
                        echo "Testing scalability and system behavior under load"
                        echo "=========================================="

                        sh """
                            # Wait for staging services to be fully ready
                            echo "Waiting 60 seconds for staging services to stabilize..."
                            sleep 60

                            # Get the staging service URL - using VM IP
                            STAGING_PORT=8082
                            VM_IP="74.161.33.56"
                            SERVICE_URL="http://\${VM_IP}:\${STAGING_PORT}"

                            echo ""
                            echo "Service URL: \${SERVICE_URL}"
                            echo ""
                            echo "=========================================="
                            echo "WAITING FOR SERVICE TO BE HEALTHY"
                            echo "=========================================="

                            # Wait for staging services to be fully ready with health check retry
                            MAX_RETRIES=12
                            RETRY_COUNT=0
                            WAIT_TIME=10

                            while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
                                echo "Health check attempt \$((RETRY_COUNT + 1))/\$MAX_RETRIES..."

                                HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" \${SERVICE_URL}/actuator/health || echo "000")

                                if [ "\$HTTP_CODE" = "200" ]; then
                                    echo "âœ… Service is healthy (HTTP \$HTTP_CODE)"
                                    break
                                else
                                    echo "âš ï¸  Service not ready yet (HTTP \$HTTP_CODE)"
                                    RETRY_COUNT=\$((RETRY_COUNT + 1))

                                    if [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; then
                                        echo "Waiting \${WAIT_TIME} seconds before next attempt..."
                                        sleep \$WAIT_TIME
                                    fi
                                fi
                            done

                            # Verify service is running
                            echo ""
                            echo "Verifying staging service status..."
                            docker service ls --filter "name=${STACK_NAME_STAGING}"

                            # Final health check
                            FINAL_HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" \${SERVICE_URL}/actuator/health || echo "000")
                            if [ "\$FINAL_HTTP_CODE" != "200" ]; then
                                echo ""
                                echo "âŒ WARNING: Service health check failed (HTTP \$FINAL_HTTP_CODE)"
                                echo "Service may not be fully ready, but continuing with load tests..."
                                echo "This may result in higher error rates in the load test results."
                            else
                                echo ""
                                echo "âœ… Service is healthy and ready for load testing"
                            fi

                            echo ""
                            echo "K6 version:"
                            k6 version

                            echo ""
                            echo "=========================================="
                            echo "STARTING K6 LOAD TESTS"
                            echo "=========================================="
                            echo ""

                            # Run k6 load tests
                            export SERVICE_URL="\${SERVICE_URL}"

                            k6 run \\
                                --out json=/tmp/k6_metrics.json \\
                                --summary-export=/tmp/k6_summary.json \\
                                -e SERVICE_URL=\${SERVICE_URL} \\
                                load-test.js

                            K6_EXIT_CODE=\$?

                            echo ""
                            echo "=========================================="
                            echo "K6 LOAD TEST COMPLETED"
                            echo "=========================================="

                            # Display results summary
                            if [ -f /tmp/load_test_results.json ]; then
                                # Extract and display key metrics
                                if command -v jq &> /dev/null; then
                                    echo "Success Rate:          \$(jq -r '.results.success_rate' /tmp/load_test_results.json)%"
                                    echo "Requests per Second:   \$(jq -r '.results.requests_per_second' /tmp/load_test_results.json) RPS"
                                    echo "Avg Response Time:     \$(jq -r '.results.response_time_ms.average' /tmp/load_test_results.json) ms"
                                    echo "P95 Response Time:     \$(jq -r '.results.response_time_ms.p95' /tmp/load_test_results.json) ms"
                                    echo ""
                                    echo "Scaling Recommendation: \$(jq -r '.scaling.recommendation' /tmp/load_test_results.json)"
                                    echo "Recommended Replicas:   \$(jq -r '.scaling.recommended_replicas' /tmp/load_test_results.json)"
                                else
                                    cat /tmp/load_test_results.json
                                fi
                            fi

                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Auto-Scale Based on Load Tests (Staging)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "AUTO-SCALING BASED ON LOAD TEST RESULTS"
                        echo "=========================================="

                        sh """
                            echo "Reading load test results and determining scaling action..."
                            echo ""

                            # Set variables for auto-scale script
                            export SERVICE_NAME="\${STACK_NAME_STAGING}_lmsbooks_command_staging"
                            export RESULTS_FILE="/tmp/load_test_results.json"
                            export MIN_REPLICAS=1
                            export MAX_REPLICAS=5

                            # Check if results file exists
                            if [ ! -f "\$RESULTS_FILE" ]; then
                                echo "âš ï¸ Load test results not found. Skipping auto-scaling."
                                exit 0
                            fi

                            echo "=========================================="
                            echo "CURRENT SERVICE STATUS"
                            echo "=========================================="
                            docker service ls --filter "name=\$SERVICE_NAME" || echo "Service not found with exact name"

                            # Try to find the service
                            ACTUAL_SERVICE=\$(docker service ls --format "{{.Name}}" | grep -E "staging.*lmsbooks|lmsbooks.*staging" | grep command | head -1 || echo "")

                            if [ -z "\$ACTUAL_SERVICE" ]; then
                                echo "Looking for any staging service..."
                                ACTUAL_SERVICE=\$(docker service ls --format "{{.Name}}" | grep staging | head -1 || echo "")
                            fi

                            if [ -n "\$ACTUAL_SERVICE" ]; then
                                export SERVICE_NAME="\$ACTUAL_SERVICE"
                                echo "Found service: \$SERVICE_NAME"
                            fi

                            echo ""
                            echo "=========================================="
                            echo "LOAD TEST RESULTS ANALYSIS"
                            echo "=========================================="

                            # Read scaling recommendation from results
                            if command -v jq &> /dev/null; then
                                RECOMMENDATION=\$(jq -r '.scaling.recommendation' "\$RESULTS_FILE")
                                RECOMMENDED_REPLICAS=\$(jq -r '.scaling.recommended_replicas' "\$RESULTS_FILE")
                                SUCCESS_RATE=\$(jq -r '.results.success_rate' "\$RESULTS_FILE")
                                RPS=\$(jq -r '.results.requests_per_second' "\$RESULTS_FILE")
                                AVG_RESPONSE=\$(jq -r '.results.response_time_ms.average' "\$RESULTS_FILE")
                            else
                                RECOMMENDATION=\$(python3 -c "import json; data=json.load(open('\$RESULTS_FILE')); print(data['scaling']['recommendation'])")
                                RECOMMENDED_REPLICAS=\$(python3 -c "import json; data=json.load(open('\$RESULTS_FILE')); print(data['scaling']['recommended_replicas'])")
                                SUCCESS_RATE=\$(python3 -c "import json; data=json.load(open('\$RESULTS_FILE')); print(data['results']['success_rate'])")
                                RPS=\$(python3 -c "import json; data=json.load(open('\$RESULTS_FILE')); print(data['results']['requests_per_second'])")
                                AVG_RESPONSE=\$(python3 -c "import json; data=json.load(open('\$RESULTS_FILE')); print(data['results']['response_time_ms']['average'])")
                            fi

                            echo "Success Rate:          \$SUCCESS_RATE%"
                            echo "Requests/Second:       \$RPS RPS"
                            echo "Avg Response Time:     \$AVG_RESPONSE ms"
                            echo "Recommendation:        \$RECOMMENDATION"
                            echo "Recommended Replicas:  \$RECOMMENDED_REPLICAS"

                            # Get current replicas
                            CURRENT_REPLICAS=\$(docker service inspect "\$SERVICE_NAME" --format '{{.Spec.Mode.Replicated.Replicas}}' 2>/dev/null || echo "1")
                            echo ""
                            echo "Current Replicas:      \$CURRENT_REPLICAS"

                            echo ""
                            echo "=========================================="
                            echo "SCALING DECISION"
                            echo "=========================================="

                            TARGET_REPLICAS=\$CURRENT_REPLICAS

                            if [ "\$RECOMMENDATION" = "scale_up" ]; then
                                TARGET_REPLICAS=\$RECOMMENDED_REPLICAS

                                # Enforce max replicas
                                if [ \$TARGET_REPLICAS -gt \$MAX_REPLICAS ]; then
                                    TARGET_REPLICAS=\$MAX_REPLICAS
                                    echo "âš ï¸ Capping at max replicas: \$MAX_REPLICAS"
                                fi

                                # Ensure we're actually scaling up
                                if [ \$TARGET_REPLICAS -le \$CURRENT_REPLICAS ]; then
                                    TARGET_REPLICAS=\$((CURRENT_REPLICAS + 1))
                                    if [ \$TARGET_REPLICAS -gt \$MAX_REPLICAS ]; then
                                        TARGET_REPLICAS=\$MAX_REPLICAS
                                    fi
                                fi

                                echo "Action: SCALE UP"
                                echo "Reason: Load test metrics indicate need for more capacity"

                            elif [ "\$RECOMMENDATION" = "scale_down" ]; then
                                TARGET_REPLICAS=\$((CURRENT_REPLICAS - 1))

                                # Enforce min replicas
                                if [ \$TARGET_REPLICAS -lt \$MIN_REPLICAS ]; then
                                    TARGET_REPLICAS=\$MIN_REPLICAS
                                fi

                                echo "Action: SCALE DOWN"
                                echo "Reason: System is over-provisioned"

                            else
                                echo "Action: NO SCALING"
                                echo "Reason: Load test metrics indicate stable performance"
                            fi

                            echo "Target Replicas:       \$TARGET_REPLICAS"
                        """
                    }
                }
            }
        }

        stage('Release Validation Tests (Staging)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "RELEASE VALIDATION TESTS - STAGING"
                        echo "=========================================="
                        echo "Running comprehensive validation tests"
                        echo "Automatic rollback will trigger if tests fail"
                        echo "=========================================="

                        // Get current service details for potential rollback
                        def serviceName = sh(
                            script: """
                                docker service ls --filter "name=${STACK_NAME_STAGING}" --format "{{.Name}}" | grep lmsbooks | grep command | head -1 || echo ""
                            """,
                            returnStdout: true
                        ).trim()

                        // Get previous image tag for rollback
                        def previousImage = sh(
                            script: """
                                if [ -f /tmp/lmsbooks_staging_previous_image.txt ]; then
                                    cat /tmp/lmsbooks_staging_previous_image.txt
                                else
                                    echo ""
                                fi
                            """,
                            returnStdout: true
                        ).trim()

                        echo "Service Name: ${serviceName}"
                        echo "Previous Image: ${previousImage}"
                        echo ""

                        // Save current image as previous for next deployment
                        sh """
                            echo "${FULL_IMAGE_NAME}:${IMAGE_TAG}" > /tmp/lmsbooks_staging_current_image.txt
                        """

                        // Make validation script executable
                        sh "chmod +x release-validation-tests.sh || true"

                        // Run validation tests
                        def validationResult = sh(
                            script: """
                                ./release-validation-tests.sh \
                                    http://74.161.33.56:8082 \
                                    staging \
                                    "${serviceName}" \
                                    "${previousImage}" \
                                    http://74.161.33.56:8085
                            """,
                            returnStatus: true
                        )

                        if (validationResult != 0) {
                            echo ""
                            echo "âŒ VALIDATION TESTS FAILED"
                            echo "Triggering automatic rollback..."
                            error("Release validation failed - automatic rollback initiated")
                        } else {
                            echo ""
                            echo "âœ… ALL VALIDATION TESTS PASSED"
                            echo "Deployment verified successfully"

                            // Update previous image for next deployment
                            sh """
                                cp /tmp/lmsbooks_staging_current_image.txt /tmp/lmsbooks_staging_previous_image.txt
                            """
                        }
                    }
                }
            }
        }


        stage('Deploy Shared PostgreSQL (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        echo "=========================================="
                        echo "DEPLOYING SHARED INFRASTRUCTURE FOR BLUE/GREEN"
                        echo "=========================================="

                        # Create lms_network_prod if it doesn't exist
                        echo "Ensuring lms_network_prod exists..."
                        docker network ls | grep -q lms_network_prod || \
                        docker network create --driver overlay --attachable lms_network_prod || true

                        echo ""
                        echo "Network status:"
                        docker network ls | grep lms_network

                        # Deploy Traefik Load Balancer
                        echo ""
                        echo "=========================================="
                        echo "DEPLOYING TRAEFIK LOAD BALANCER"
                        echo "=========================================="

                        if docker stack ls | grep -q "lmsbooks-prod-traefik"; then
                            echo "âœ… Traefik already deployed - updating..."
                        else
                            echo "ðŸ“¦ Deploying Traefik for the first time..."
                        fi

                        docker stack deploy -c docker-compose-swarm-prod-traefik.yml lmsbooks-prod-traefik

                        echo "Waiting for Traefik to be ready..."
                        sleep 15

                        TRAEFIK_SERVICE=\$(docker service ls --filter "name=lmsbooks-prod-traefik_traefik" --format "{{.Name}}" || echo "")
                        if [ -n "\$TRAEFIK_SERVICE" ]; then
                            echo "âœ… Traefik service: \$TRAEFIK_SERVICE"
                            docker service ps \$TRAEFIK_SERVICE --format "  {{.Name}}: {{.CurrentState}}" | head -3
                        fi

                        echo ""
                        echo "âœ… Traefik deployed successfully!"
                        echo "   - Load Balancer Port: 8080 (main entry point)"
                        echo "   - Dashboard: http://localhost:8090/dashboard/"
                        echo ""

                        # Deploy PostgreSQL
                        echo "=========================================="
                        echo "DEPLOYING SHARED POSTGRESQL"
                        echo "=========================================="

                        # Check if PostgreSQL stack already exists
                        if docker stack ls | grep -q "lmsbooks-prod-postgres"; then
                            echo ""
                            echo "âœ… PostgreSQL stack already exists - updating..."
                        else
                            echo ""
                            echo "ðŸ“¦ Creating new PostgreSQL stack..."
                        fi

                        # Deploy shared PostgreSQL
                        docker stack deploy -c docker-compose-swarm-prod-postgres.yml lmsbooks-prod-postgres

                        echo ""
                        echo "Waiting for PostgreSQL to be ready..."
                        sleep 20

                        # Verify PostgreSQL is running
                        PG_SERVICE=\$(docker service ls --filter "name=lmsbooks-prod-postgres_postgres_command_prod" --format "{{.Name}}" || echo "")

                        if [ -n "\$PG_SERVICE" ]; then
                            echo "âœ… PostgreSQL service: \$PG_SERVICE"
                            docker service ps \$PG_SERVICE --format "  {{.Name}}: {{.CurrentState}}"

                            # Wait for PostgreSQL to be healthy
                            echo ""
                            echo "Waiting for PostgreSQL to become healthy..."
                            MAX_WAIT=60
                            ELAPSED=0
                            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                REPLICAS=\$(docker service ls --filter "name=\$PG_SERVICE" --format "{{.Replicas}}")
                                echo "PostgreSQL status: \$REPLICAS (elapsed: \${ELAPSED}s)"

                                if echo "\$REPLICAS" | grep -q "1/1"; then
                                    echo "âœ… PostgreSQL is ready!"
                                    break
                                fi

                                sleep 5
                                ELAPSED=\$((ELAPSED + 5))
                            done
                        else
                            echo "âŒ ERROR: PostgreSQL service not found!"
                            exit 1
                        fi

                        echo ""
                        echo "=========================================="
                        echo "âœ… Shared Infrastructure Ready!"
                        echo "=========================================="
                        echo "Traefik Load Balancer:"
                        echo "   - Main Entry: http://localhost:8080"
                        echo "   - Dashboard: http://localhost:8090/dashboard/"
                        echo ""
                        echo "PostgreSQL Database:"
                        echo "   - Service: lmsbooks-prod-postgres_postgres_command_prod"
                        echo "   - Database: lmsbooks_prod"
                        echo "   - Port: 5434 (external), 5432 (internal)"
                        echo "=========================================="
                    """
                }
            }
        }

        stage('Manual Approval for Production') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                script {
                    def strategyInfo = params.DEPLOYMENT_STRATEGY == 'blue-green' ?
                        "Blue/Green Deployment (Zero-downtime with instant rollback)" :
                        "Rolling Update (Gradual update with automatic rollback)"

                    echo "=========================================="
                    echo "PRODUCTION DEPLOYMENT APPROVAL REQUIRED"
                    echo "=========================================="
                    echo "Project: LMS Books Command Service"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Image Tag: ${IMAGE_TAG}"
                    echo "Environment: PRODUCTION"
                    echo "Deployment Strategy: ${params.DEPLOYMENT_STRATEGY.toUpperCase()}"
                    echo ""
                    if (params.DEPLOYMENT_STRATEGY == 'blue-green') {
                        echo "Blue/Green Strategy:"
                        echo "  - Deploy to inactive environment"
                        echo "  - Run health checks on new environment"
                        echo "  - Switch traffic instantly"
                        echo "  - Keep old environment for instant rollback"
                    } else {
                        echo "Rolling Update Strategy:"
                        echo "  - Update 1 container at a time"
                        echo "  - 10-second delay between updates"
                        echo "  - Health checks before proceeding"
                        echo "  - Automatic rollback on failure"
                    }
                    echo "=========================================="

                    // Try to send email notification
                    try {
                        mail(
                            to: "${EMAIL_RECIPIENT}",
                            subject: "Jenkins: Production Deployment Approval Required - Build #${BUILD_NUMBER}",
                            body: """
                                Production Deployment Approval Required
                                =======================================

                                Project: LMS Books Command Service
                                Build Number: ${BUILD_NUMBER}
                                Image Tag: ${IMAGE_TAG}
                                Environment: PRODUCTION
                                Deployment Strategy: ${params.DEPLOYMENT_STRATEGY.toUpperCase()}

                                ${strategyInfo}

                                Please review and approve/reject the deployment to production.

                                Approve or reject at: ${BUILD_URL}input/

                                View full build details: ${BUILD_URL}
                            """,
                            mimeType: 'text/plain'
                        )
                        echo "âœ… Email notification sent successfully to ${EMAIL_RECIPIENT}"
                    } catch (Exception e) {
                        echo "âš ï¸ WARNING: Could not send email notification"
                        echo "Email error: ${e.message}"
                        echo "Continuing with manual approval process..."
                    }

                    timeout(time: 30, unit: 'MINUTES') {
                        input message: 'Approve Production Deployment?', ok: 'Deploy'
                    }
                }
            }
        }

        stage('Determine Active Environment (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                script {
                    sh """
                        echo "=========================================="
                        echo "BLUE/GREEN DEPLOYMENT - ENVIRONMENT CHECK"
                        echo "=========================================="

                        # Check which environment is currently active
                        BLUE_RUNNING=\$(docker service ls --filter "name=${STACK_NAME_PROD_BLUE}_lmsbooks_command_blue" --format "{{.Replicas}}" 2>/dev/null | grep -v "0/0" | head -1 || echo "")
                        GREEN_RUNNING=\$(docker service ls --filter "name=${STACK_NAME_PROD_GREEN}_lmsbooks_command_green" --format "{{.Replicas}}" 2>/dev/null | grep -v "0/0" | head -1 || echo "")

                        echo "Blue environment status: \${BLUE_RUNNING:-not deployed}"
                        echo "Green environment status: \${GREEN_RUNNING:-not deployed}"

                        # Read current live environment from file (if exists)
                        if [ -f "${LIVE_ENV_FILE}" ]; then
                            CURRENT_LIVE=\$(cat ${LIVE_ENV_FILE})
                            echo "Current live environment (from file): \$CURRENT_LIVE"
                        else
                            CURRENT_LIVE=""
                            echo "No live environment file found - first deployment"
                        fi

                        # Determine which environment to deploy to
                        if [ "\$CURRENT_LIVE" = "blue" ]; then
                            TARGET_ENV="green"
                            INACTIVE_ENV="blue"
                        elif [ "\$CURRENT_LIVE" = "green" ]; then
                            TARGET_ENV="blue"
                            INACTIVE_ENV="green"
                        elif [ -n "\$BLUE_RUNNING" ] && [ -z "\$GREEN_RUNNING" ]; then
                            # Blue is running, deploy to green
                            TARGET_ENV="green"
                            INACTIVE_ENV="blue"
                            echo "blue" > ${LIVE_ENV_FILE}
                        elif [ -n "\$GREEN_RUNNING" ] && [ -z "\$BLUE_RUNNING" ]; then
                            # Green is running, deploy to blue
                            TARGET_ENV="blue"
                            INACTIVE_ENV="green"
                            echo "green" > ${LIVE_ENV_FILE}
                        else
                            # First deployment - start with blue
                            TARGET_ENV="blue"
                            INACTIVE_ENV=""
                            echo "First deployment - deploying to blue environment"
                        fi

                        echo ""
                        echo "=========================================="
                        echo "Deployment Plan:"
                        echo "  - Current Live: \${CURRENT_LIVE:-none}"
                        echo "  - Target Environment: \$TARGET_ENV"
                        echo "  - Will become inactive: \${INACTIVE_ENV:-none}"
                        echo "=========================================="

                        # Save target environment for next stages
                        echo "\$TARGET_ENV" > /tmp/lmsbooks_target_env.txt
                        echo "\${INACTIVE_ENV:-none}" > /tmp/lmsbooks_inactive_env.txt
                    """

                    // Read target environment into pipeline variable
                    env.TARGET_ENV = sh(script: "cat /tmp/lmsbooks_target_env.txt", returnStdout: true).trim()
                    env.INACTIVE_ENV = sh(script: "cat /tmp/lmsbooks_inactive_env.txt", returnStdout: true).trim()

                    echo "Target environment for deployment: ${env.TARGET_ENV}"
                }
            }
        }

        stage('Deploy to Inactive Environment (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        def targetEnv = env.TARGET_ENV
                        def stackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN
                        def composeFile = targetEnv == 'blue' ? 'docker-compose-swarm-prod-blue.yml' : 'docker-compose-swarm-prod-green.yml'
                        def port = targetEnv == 'blue' ? env.BLUE_PORT : env.GREEN_PORT

                        echo "=========================================="
                        echo "DEPLOYING TO ${targetEnv.toUpperCase()} ENVIRONMENT"
                        echo "=========================================="
                        echo "Stack: ${stackName}"
                        echo "Compose File: ${composeFile}"
                        echo "Port: ${port}"
                        echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"

                        sh """
                            export IMAGE_TAG=${IMAGE_TAG}

                            echo ""
                            echo "Deploying ${targetEnv} environment..."
                            docker stack deploy -c ${composeFile} ${stackName}

                            echo ""
                            echo "Waiting for ${targetEnv} environment to start..."
                            sleep 30

                            # Get service name
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}" | grep lmsbooks | head -1)

                            if [ -z "\$SERVICE_NAME" ]; then
                                echo "âŒ ERROR: Service was not created!"
                                exit 1
                            fi

                            echo "Service name: \$SERVICE_NAME"

                            # Wait for replicas to be ready
                            EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                            echo "Expected replicas: \$EXPECTED_REPLICAS"

                            MAX_WAIT=180
                            ELAPSED=0

                            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")
                                echo "Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS (elapsed: \${ELAPSED}s)"

                                if [ "\$RUNNING_REPLICAS" -ge "\$EXPECTED_REPLICAS" ]; then
                                    echo "âœ… All replicas are running!"
                                    break
                                fi

                                sleep 10
                                ELAPSED=\$((ELAPSED + 10))
                            done

                            if [ "\$RUNNING_REPLICAS" -lt "\$EXPECTED_REPLICAS" ]; then
                                echo "âŒ Not all replicas started in time"
                                docker service logs --tail 50 \$SERVICE_NAME || true
                                exit 1
                            fi

                            echo ""
                            echo "=========================================="
                            echo "âœ… ${targetEnv.toUpperCase()} environment deployed successfully!"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Health Check New Environment (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                script {
                    def targetEnv = env.TARGET_ENV
                    def stackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN
                    def port = targetEnv == 'blue' ? env.BLUE_PORT : env.GREEN_PORT

                    echo "=========================================="
                    echo "HEALTH CHECK - ${targetEnv.toUpperCase()} ENVIRONMENT"
                    echo "=========================================="

                    sh """
                        echo "Waiting for health checks to stabilize..."
                        sleep 30

                        # Get service name
                        SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}" | grep lmsbooks | head -1)

                        echo "Checking health of service: \$SERVICE_NAME"
                        echo ""

                        # Get expected replicas
                        EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                        echo "Expected replicas: \$EXPECTED_REPLICAS"
                        echo ""

                        # Check service health and show detailed status
                        echo "Replica Status Details:"
                        echo "----------------------------------------"
                        docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "No tasks found"

                        echo ""
                        TASKS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)
                        HEALTHY_COUNT=0
                        TOTAL_COUNT=0
                        RUNNING_COUNT=0

                        for TASK in \$TASKS; do
                            TOTAL_COUNT=\$((TOTAL_COUNT + 1))
                            CONTAINER_ID=\$(docker inspect \$TASK --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")
                            TASK_NAME=\$(docker inspect \$TASK --format "{{.Name}}" 2>/dev/null)
                            TASK_STATE=\$(docker inspect \$TASK --format "{{.Status.State}}" 2>/dev/null || echo "unknown")

                            if [ -n "\$CONTAINER_ID" ]; then
                                HEALTH=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "none")

                                # Count as running if task state is "running"
                                if [ "\$TASK_STATE" = "running" ]; then
                                    RUNNING_COUNT=\$((RUNNING_COUNT + 1))
                                fi

                                if [ "\$HEALTH" = "healthy" ]; then
                                    echo "  âœ… \$TASK_NAME: HEALTHY (state: \$TASK_STATE)"
                                    HEALTHY_COUNT=\$((HEALTHY_COUNT + 1))
                                elif [ "\$HEALTH" = "starting" ]; then
                                    echo "  ðŸ”„ \$TASK_NAME: STARTING (state: \$TASK_STATE)"
                                    # Give it more time
                                    sleep 30
                                    HEALTH=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "none")
                                    TASK_STATE=\$(docker inspect \$TASK --format "{{.Status.State}}" 2>/dev/null || echo "unknown")
                                    if [ "\$HEALTH" = "healthy" ]; then
                                        echo "  âœ… \$TASK_NAME: NOW HEALTHY (state: \$TASK_STATE)"
                                        HEALTHY_COUNT=\$((HEALTHY_COUNT + 1))
                                        if [ "\$TASK_STATE" = "running" ]; then
                                            RUNNING_COUNT=\$((RUNNING_COUNT + 1))
                                        fi
                                    fi
                                else
                                    echo "  â„¹ï¸  \$TASK_NAME: \${HEALTH} (state: \$TASK_STATE)"
                                    # If task is running but health check not configured, count it
                                    if [ "\$TASK_STATE" = "running" ] && [ "\$HEALTH" = "none" ]; then
                                        echo "      (No health check configured - counting as healthy based on running state)"
                                        HEALTHY_COUNT=\$((HEALTHY_COUNT + 1))
                                    fi
                                fi
                            else
                                echo "  âš ï¸  \$TASK_NAME: Container not yet available (state: \$TASK_STATE)"
                            fi
                        done

                        echo ""
                        echo "Summary:"
                        echo "  Total tasks: \$TOTAL_COUNT"
                        echo "  Running tasks: \$RUNNING_COUNT"
                        echo "  Healthy/Ready tasks: \$HEALTHY_COUNT"
                        echo "  Expected replicas: \$EXPECTED_REPLICAS"

                        # Consider deployment successful if we have the expected number of running replicas
                        # Health checks might still be starting, which is acceptable
                        if [ "\$RUNNING_COUNT" -ge "\$EXPECTED_REPLICAS" ]; then
                            echo ""
                            echo "=========================================="
                            echo "âœ… Health check PASSED!"
                            echo "   All \$RUNNING_COUNT/\$EXPECTED_REPLICAS replicas are running"
                            if [ "\$HEALTHY_COUNT" -lt "\$EXPECTED_REPLICAS" ]; then
                                echo "   âš ï¸  Note: Some health checks still initializing (this is normal)"
                            fi
                            echo "=========================================="
                        else
                            echo ""
                            echo "=========================================="
                            echo "âŒ Health check FAILED!"
                            echo "   Only \$RUNNING_COUNT/\$EXPECTED_REPLICAS replicas running"
                            echo ""
                            echo "Detailed task information:"
                            docker service ps \$SERVICE_NAME --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" --no-trunc
                            echo ""
                            echo "Service logs (last 50 lines):"
                            docker service logs --tail 50 \$SERVICE_NAME || true
                            echo "=========================================="
                            exit 1
                        fi
                    """
                }
            }
        }

        stage('Switch Traffic (Blue/Green)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'blue-green' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        def targetEnv = env.TARGET_ENV
                        def inactiveEnv = env.INACTIVE_ENV
                        def targetStackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN
                        def inactiveStackName = inactiveEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN

                        echo "=========================================="
                        echo "SWITCHING TRAFFIC TO ${targetEnv.toUpperCase()} (TRAEFIK)"
                        echo "=========================================="

                        sh """
                            echo "New live environment: ${targetEnv}"
                            echo "Previous live: ${inactiveEnv}"

                            # Determine priorities
                            if [ "${targetEnv}" = "blue" ]; then
                                NEW_BLUE_PRIORITY=100
                                NEW_GREEN_PRIORITY=1
                            else
                                NEW_BLUE_PRIORITY=1
                                NEW_GREEN_PRIORITY=100
                            fi

                            echo ""
                            echo "Setting Traefik routing priorities..."
                            echo "Blue priority: \$NEW_BLUE_PRIORITY"
                            echo "Green priority: \$NEW_GREEN_PRIORITY"

                            # Get service names
                            BLUE_SERVICE=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD_BLUE}" --format "{{.Name}}" | grep lmsbooks | head -1)
                            GREEN_SERVICE=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD_GREEN}" --format "{{.Name}}" | grep lmsbooks | head -1)

                            # Get current images to show in output
                            if [ -n "\$BLUE_SERVICE" ]; then
                                BLUE_IMAGE=\$(docker service inspect \$BLUE_SERVICE --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Blue current image: \$BLUE_IMAGE"
                                # Save blue image to file for rollback reference
                                echo "\$BLUE_IMAGE" > ${BLUE_IMAGE_FILE}
                            fi

                            if [ -n "\$GREEN_SERVICE" ]; then
                                GREEN_IMAGE=\$(docker service inspect \$GREEN_SERVICE --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Green current image: \$GREEN_IMAGE"
                                # Save green image to file for rollback reference
                                echo "\$GREEN_IMAGE" > ${GREEN_IMAGE_FILE}
                            fi

                            # Update priorities via docker service update (preserves images)
                            echo ""
                            echo "Updating service priorities (without changing images)..."

                            # Update Blue service priority
                            if [ -n "\$BLUE_SERVICE" ]; then
                                echo "Updating Blue priority to \$NEW_BLUE_PRIORITY..."
                                docker service update \\
                                    --label-add "traefik.http.routers.lmsbooks-blue.priority=\$NEW_BLUE_PRIORITY" \\
                                    \$BLUE_SERVICE
                            fi

                            # Update Green service priority
                            if [ -n "\$GREEN_SERVICE" ]; then
                                echo "Updating Green priority to \$NEW_GREEN_PRIORITY..."
                                docker service update \\
                                    --label-add "traefik.http.routers.lmsbooks-green.priority=\$NEW_GREEN_PRIORITY" \\
                                    \$GREEN_SERVICE
                            fi

                            # Update the live environment file
                            echo "${targetEnv}" > ${LIVE_ENV_FILE}

                            echo ""
                            echo "Waiting 10 seconds for Traefik to update routing..."
                            sleep 10

                            echo ""
                            echo "=========================================="
                            echo "âœ… Traffic switched to ${targetEnv.toUpperCase()} via Traefik!"
                            echo "=========================================="
                            echo "Traefik Load Balancer:"
                            echo "  - Main Entry: http://74.161.33.56:8085"
                            echo "  - Dashboard: http://74.161.33.56:8090/dashboard/"
                            echo ""
                            echo "Live Environment: ${targetEnv.toUpperCase()}"
                            echo "  - Stack: ${targetStackName}"
                            echo "  - Priority: \$NEW_BLUE_PRIORITY (if blue) or \$NEW_GREEN_PRIORITY (if green)"
                            echo "  - Image: \$([ "${targetEnv}" = "blue" ] && echo "\$BLUE_IMAGE" || echo "\$GREEN_IMAGE")"
                            echo ""
                            echo "Standby Environment: ${inactiveEnv.toUpperCase()}"
                            echo "  - Stack: ${inactiveStackName}"
                            echo "  - Priority: \$([ "${inactiveEnv}" = "blue" ] && echo "\$NEW_BLUE_PRIORITY" || echo "\$NEW_GREEN_PRIORITY")"
                            echo "  - Image: \$([ "${inactiveEnv}" = "blue" ] && echo "\$BLUE_IMAGE" || echo "\$GREEN_IMAGE")"
                            echo ""
                            echo "âš ï¸  NOTE: Both environments remain running with PRESERVED images for instant rollback"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Deploy to Production (Rolling Update + Rollback)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.DEPLOYMENT_STRATEGY == 'rolling' }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "Starting PROD rolling update with image ${IMAGE_NAME}:${IMAGE_TAG}"

                        sh """
                            # Check if service already exists
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_command" --format "{{.Name}}" 2>/dev/null || echo "")

                            if [ -z "\$SERVICE_NAME" ]; then
                                echo "=========================================="
                                echo "âš ï¸ Service does not exist yet - First deployment"
                                echo "Creating stack for the first time..."
                                echo "=========================================="

                                # First deployment - just create the stack
                                export IMAGE_TAG=${IMAGE_TAG}
                                docker stack deploy -c docker-compose-swarm-prod.yml ${STACK_NAME_PROD}

                                echo "Waiting for services to start..."
                                sleep 30

                                # Get the newly created service name
                                SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_command" --format "{{.Name}}")

                                if [ -z "\$SERVICE_NAME" ]; then
                                    echo "âŒ ERROR: Service was not created!"
                                    exit 1
                                fi

                                # Check if all replicas are running
                                EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                                echo "Expected replicas: \$EXPECTED_REPLICAS"

                                MAX_WAIT=180
                                ELAPSED=0

                                while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                    RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running")
                                    echo "Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS (elapsed: \${ELAPSED}s)"

                                    if [ \$RUNNING_REPLICAS -ge \$EXPECTED_REPLICAS ]; then
                                        echo "âœ… All replicas are running - first deployment successful!"
                                        break
                                    fi

                                    sleep 10
                                    ELAPSED=\$((ELAPSED + 10))
                                done

                                if [ \$RUNNING_REPLICAS -lt \$EXPECTED_REPLICAS ]; then
                                    echo "âŒ Not all replicas started in time"
                                    docker service logs --tail 50 \$SERVICE_NAME || true
                                    exit 1
                                fi

                            else
                                echo "=========================================="
                                echo "âœ“ Service exists - Performing Rolling Update"
                                echo "Service name: \$SERVICE_NAME"
                                echo "=========================================="

                                # Save old image for rollback
                                OLD_IMAGE=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Old image: \$OLD_IMAGE"
                                echo "New image: ${IMAGE_NAME}:${IMAGE_TAG}"

                                # Deploy new image with rolling update
                                export IMAGE_TAG=${IMAGE_TAG}
                                docker stack deploy -c docker-compose-swarm-prod.yml ${STACK_NAME_PROD}

                                echo "Docker Swarm is performing rolling update..."
                                echo "Monitoring service update progress..."

                                # Wait for deployment to start
                                sleep 20

                                # Get expected replicas
                                EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                                echo "Expected replicas: \$EXPECTED_REPLICAS"

                                # Monitor rolling update
                                MAX_WAIT=300
                                ELAPSED=0
                                UPDATE_COMPLETE=false

                                while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                    STATUS=\$(docker service inspect \$SERVICE_NAME --format '{{.UpdateStatus.State}}' 2>/dev/null || echo "")
                                    RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")

                                    echo "Update status: \${STATUS:-none} | Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS | Elapsed: \${ELAPSED}s"

                                    # Check if update completed
                                    if [ "\$STATUS" = "completed" ]; then
                                        echo "âœ… Rolling update completed successfully!"
                                        UPDATE_COMPLETE=true
                                        break
                                    # Check if all replicas are running (even if status is unknown)
                                    elif [ \$RUNNING_REPLICAS -ge \$EXPECTED_REPLICAS ] && [ \$ELAPSED -gt 30 ]; then
                                        echo "âœ… All replicas running - deployment successful!"
                                        UPDATE_COMPLETE=true
                                        break
                                    # Check for failures
                                    elif [ "\$STATUS" = "rollback_completed" ]; then
                                        echo "âŒ Swarm automatic rollback completed!"
                                        echo "Checking service logs..."
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        exit 1
                                    elif [ "\$STATUS" = "paused" ]; then
                                        echo "âŒ Update paused - rolling back manually to \$OLD_IMAGE..."
                                        docker service update --image \$OLD_IMAGE \$SERVICE_NAME
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        exit 1
                                    fi

                                    # Show current replicas status
                                    docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" 2>/dev/null || true

                                    sleep 10
                                    ELAPSED=\$((ELAPSED + 10))
                                done

                                # Handle timeout
                                if [ "\$UPDATE_COMPLETE" = "false" ]; then
                                    echo "âš ï¸ Rolling update timed out. Checking final status..."
                                    FINAL_RUNNING=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")

                                    if [ \$FINAL_RUNNING -ge \$EXPECTED_REPLICAS ]; then
                                        echo "âœ… All replicas confirmed running - deployment successful!"
                                        UPDATE_COMPLETE=true
                                    else
                                        echo "âŒ Not all replicas running. Rolling back to \$OLD_IMAGE..."
                                        docker service update --image \$OLD_IMAGE \$SERVICE_NAME
                                        echo "Waiting for rollback to complete..."
                                        sleep 20
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        docker service ps \$SERVICE_NAME || true
                                        exit 1
                                    fi
                                fi
                            fi

                            echo "=========================================="
                            echo "Production deployment completed successfully!"
                            echo "All replicas running version ${IMAGE_TAG}"
                            echo "=========================================="

                            # Final status
                            docker stack services ${STACK_NAME_PROD}
                            docker stack ps ${STACK_NAME_PROD}

                            # Health Check Status
                            echo ""
                            echo "=========================================="
                            echo "HEALTH CHECK STATUS - PRODUCTION"
                            echo "=========================================="

                            # Get service name
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_command" --format "{{.Name}}")

                            if [ -n "\$SERVICE_NAME" ]; then
                                echo ""
                                echo "Service: \$SERVICE_NAME"
                                echo "----------------------------------------"

                                # Get all task IDs for the service
                                TASK_IDS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)

                                for TASK_ID in \$TASK_IDS; do
                                    # Get container ID from task
                                    CONTAINER_ID=\$(docker inspect \$TASK_ID --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")

                                    if [ -n "\$CONTAINER_ID" ]; then
                                        echo ""
                                        echo "Task: \$TASK_ID"
                                        HEALTH_STATUS=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "no healthcheck")

                                        if [ "\$HEALTH_STATUS" != "no healthcheck" ]; then
                                            echo "  Health Status: \$HEALTH_STATUS"

                                            # Get last health check log
                                            LAST_CHECK=\$(docker inspect \$CONTAINER_ID --format "{{range .State.Health.Log}}{{.End}} - {{.ExitCode}} - {{.Output}}{{end}}" 2>/dev/null | tail -1 || echo "N/A")
                                            echo "  Last Check: \$LAST_CHECK"
                                        else
                                            echo "  Health Status: Not configured or starting"
                                        fi

                                        # Show replica state
                                        REPLICA_STATE=\$(docker service ps \$SERVICE --filter "id=\$TASK" --format "{{.CurrentState}}" 2>/dev/null)
                                        echo "  Replica State: \$REPLICA_STATE"
                                    fi
                                done

                                echo ""
                                echo "----------------------------------------"
                                echo "Health Check Configuration:"
                                docker service inspect \$SERVICE_NAME --format "{{json .Spec.TaskTemplate.ContainerSpec.Healthcheck}}" 2>/dev/null | python3 -m json.tool 2>/dev/null || echo "  Configured in docker-compose file"
                            fi

                            # Check health of all services in the stack
                            echo ""
                            echo "=========================================="
                            echo "ALL SERVICES HEALTH STATUS"
                            echo "=========================================="
                            docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

                            echo ""
                            echo "Detailed service inspection:"
                            for SERVICE in \$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --format "{{.Name}}"); do
                                echo ""
                                echo "Service: \$SERVICE"
                                docker service ps \$SERVICE --format "  {{.Name}}: {{.CurrentState}}" | head -5
                            done

                            echo ""
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Post-Deployment Verification') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                script {
                    // Determine correct stack name based on deployment strategy and environment
                    def stackName

                    if (params.ENVIRONMENT == 'prod' && params.DEPLOYMENT_STRATEGY == 'blue-green') {
                        // For Blue/Green, verify the target environment that was just deployed
                        def targetEnv = env.TARGET_ENV ?: 'blue'
                        stackName = targetEnv == 'blue' ? env.STACK_NAME_PROD_BLUE : env.STACK_NAME_PROD_GREEN

                        echo "=========================================="
                        echo "POST-DEPLOYMENT VERIFICATION (BLUE/GREEN)"
                        echo "Environment: ${params.ENVIRONMENT}"
                        echo "Deployment Strategy: Blue/Green"
                        echo "Active Environment: ${targetEnv}"
                        echo "Stack Name: ${stackName}"
                        echo "=========================================="
                    } else {
                        // For dev, staging, or rolling update
                        stackName = params.ENVIRONMENT == 'dev' ? env.STACK_NAME_DEV :
                                   (params.ENVIRONMENT == 'staging' ? env.STACK_NAME_STAGING : env.STACK_NAME_PROD)

                        echo "=========================================="
                        echo "POST-DEPLOYMENT VERIFICATION"
                        echo "Environment: ${params.ENVIRONMENT}"
                        echo "Stack Name: ${stackName}"
                        echo "=========================================="
                    }

                    sh """
                        # Wait for Docker Swarm to update replica status
                        echo ""
                        echo "Waiting 15 seconds for Docker Swarm to update replica status..."
                        sleep 15

                        echo ""
                        echo "Current service status:"
                        docker stack services ${stackName} || echo "âš ï¸ Stack ${stackName} may not exist yet"

                        echo ""
                        echo "Service tasks:"
                        docker stack ps ${stackName} --no-trunc || echo "âš ï¸ No tasks found for stack ${stackName}"

                        echo ""
                        echo "=========================================="
                    """

                    // Show health checks for production only
                    if (params.ENVIRONMENT == 'prod') {
                        // For Blue/Green, show both environments if they exist
                        if (params.DEPLOYMENT_STRATEGY == 'blue-green') {
                            sh """
                                echo ""
                                echo "=========================================="
                                echo "BLUE/GREEN ENVIRONMENT STATUS"
                                echo "=========================================="

                                echo ""
                                echo "BLUE Environment (${env.STACK_NAME_PROD_BLUE}):"
                                echo "----------------------------------------"
                                docker service ls --filter "label=com.docker.stack.namespace=${env.STACK_NAME_PROD_BLUE}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}" 2>/dev/null || echo "Not deployed"

                                echo ""
                                echo "GREEN Environment (${env.STACK_NAME_PROD_GREEN}):"
                                echo "----------------------------------------"
                                docker service ls --filter "label=com.docker.stack.namespace=${env.STACK_NAME_PROD_GREEN}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}" 2>/dev/null || echo "Not deployed"

                                echo ""
                                echo "Current Live Environment:"
                                if [ -f "${env.LIVE_ENV_FILE}" ]; then
                                    LIVE=\$(cat ${env.LIVE_ENV_FILE})
                                    # Convert to uppercase using tr instead of bash-specific syntax
                                    LIVE_UPPER=\$(echo "\$LIVE" | tr '[:lower:]' '[:upper:]')
                                    echo "  âœ… \${LIVE_UPPER} is LIVE"

                                    if [ "\$LIVE" = "blue" ]; then
                                        echo "  ðŸ“ Access at: http://localhost:${env.BLUE_PORT}"
                                    else
                                        echo "  ðŸ“ Access at: http://localhost:${env.GREEN_PORT}"
                                    fi
                                else
                                    echo "  âš ï¸ Live environment file not found"
                                fi
                                echo "=========================================="
                            """
                        }

                        sh """
                            echo ""
                            echo "=========================================="
                            echo "POST-DEPLOYMENT HEALTH CHECK VERIFICATION"
                            echo "=========================================="

                            # Wait a bit for health checks to stabilize
                            echo "Waiting 30 seconds for health checks to stabilize..."
                            sleep 30

                            # Check each service
                            for SERVICE in \$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}"); do
                                echo ""
                                echo "Checking health of: \$SERVICE"
                                echo "----------------------------------------"

                                # Get task IDs
                                TASKS=\$(docker service ps \$SERVICE --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)

                                for TASK in \$TASKS; do
                                    CONTAINER_ID=\$(docker inspect \$TASK --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")

                                    if [ -n "\$CONTAINER_ID" ]; then
                                        echo ""
                                        echo "Task: \$TASK"
                                        HEALTH_STATUS=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "no healthcheck")

                                        if [ "\$HEALTH_STATUS" != "no healthcheck" ]; then
                                            echo "  Health Status: \$HEALTH_STATUS"

                                            # Get last health check log
                                            LAST_CHECK=\$(docker inspect \$CONTAINER_ID --format "{{range .State.Health.Log}}{{.End}} - {{.ExitCode}} - {{.Output}}{{end}}" 2>/dev/null | tail -1 || echo "N/A")
                                            echo "  Last Check: \$LAST_CHECK"
                                        else
                                            echo "  Health Status: Not configured or starting"
                                        fi

                                        # Show replica state
                                        REPLICA_STATE=\$(docker service ps \$SERVICE --filter "id=\$TASK" --format "{{.CurrentState}}" 2>/dev/null)
                                        echo "  Replica State: \$REPLICA_STATE"
                                    fi
                                done

                                echo ""
                                echo "----------------------------------------"
                                echo "Health Check Configuration:"
                                docker service inspect \$SERVICE --format "{{json .Spec.TaskTemplate.ContainerSpec.Healthcheck}}" 2>/dev/null | python3 -m json.tool 2>/dev/null || echo "  Configured in docker-compose file"
                            done

                            echo ""
                            echo "=========================================="
                            echo "âœ… Post-deployment verification completed"
                            echo "=========================================="
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                echo "=========================================="
                echo "Pipeline completed successfully!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "SUCCESS: LMS Books Command - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Successful</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Image Tag:</strong> ${IMAGE_TAG}</p>
                            <p><strong>Status:</strong> âœ… SUCCESS</p>
                            <br>
                            <p><a href="${BUILD_URL}">View Build Details</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "âœ… Success notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "âš ï¸ WARNING: Could not send success email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }

        failure {
            script {
                echo "=========================================="
                echo "Pipeline failed!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "FAILURE: LMS Books Command - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Failed</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Status:</strong> âŒ FAILURE</p>
                            <br>
                            <p><a href="${BUILD_URL}console">View Console Output</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "âœ… Failure notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "âš ï¸ WARNING: Could not send failure email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }
    }
}

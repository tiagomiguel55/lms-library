pipeline {
    agent any

    environment {
        // Maven e Java
        MAVEN_HOME = '/usr/share/maven'
        JAVA_HOME  = '/usr/lib/jvm/java-17-openjdk-amd64'

        // Git
        GIT_REPO_URL   = 'https://github.com/tiagomiguel55/lms-library.git'
        GIT_BRANCH    = 'main'
        CREDENTIALS_ID = 'password_for_github_tiago'

        // Docker Registry
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_REGISTRY_CREDENTIALS = 'dockerhub-credentials'
        DOCKER_REGISTRY_NAMESPACE = 'tiagomiguel55'

        // Docker
        IMAGE_NAME = 'lmslendings'
        IMAGE_TAG  = "${GIT_COMMIT}"
        FULL_IMAGE_NAME = "${DOCKER_REGISTRY}/${DOCKER_REGISTRY_NAMESPACE}/${IMAGE_NAME}"

        // Swarm stacks
        STACK_NAME_DEV     = 'lmslendings-dev'
        STACK_NAME_STAGING = 'lmslendings-staging'
        STACK_NAME_PROD    = 'lmslendings-prod'

        // Email
        EMAIL_RECIPIENT = 'migueltiago255@gmail.com'

        // Working directory
        WORK_DIR = 'P2/lms_lendings_command'
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Deployment environment'
        )
        booleanParam(
            name: 'SKIP_DEPLOY',
            defaultValue: false,
            description: 'Skip deployment'
        )
        booleanParam(
            name: 'RUN_LOAD_TESTS',
            defaultValue: true,
            description: 'Run K6 load tests in staging environment'
        )
        booleanParam(
            name: 'AUTO_SCALE',
            defaultValue: true,
            description: 'Auto-scale services based on load test results'
        )
        }

        stage('Build & Package') {
            when {
                expression { params.ENVIRONMENT != 'prod' }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        ${MAVEN_HOME}/bin/mvn clean package -DskipTests
                    """
                }
            }
        }

        stage('Build Docker Image') {
            when {
                expression { params.ENVIRONMENT != 'prod' }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
                        docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${params.ENVIRONMENT}
                    """
                }
            }
        }

        stage('Push Docker Image to Registry') {
            when {
                expression { params.ENVIRONMENT == 'dev' || params.ENVIRONMENT == 'staging' }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pushing image to registry..."
                            echo "Environment: ${params.ENVIRONMENT}"
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Namespace: ${DOCKER_REGISTRY_NAMESPACE}"
                            echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Tagging for registry..."
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "Pushing image..."
                            docker push ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker push ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Image pushed to registry!"
                            echo "   ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Pull Docker Image from Registry') {
            when {
                expression { params.ENVIRONMENT == 'prod' }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pulling image from registry for Production..."
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Image: ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Pulling image..."
                            docker pull ${FULL_IMAGE_NAME}:${IMAGE_TAG}

                            echo ""
                            echo "Tagging as prod and local name..."
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "Pushing prod tag to registry..."
                            docker push ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Production image ready!"
                            echo "   Local: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   Registry: ${FULL_IMAGE_NAME}:prod"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Initialize Docker Swarm') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh '''
                    docker info | grep -q "Swarm: active" || docker swarm init || true
                    docker network ls | grep -q lms_network || \
                    docker network create --driver overlay --attachable lms_network || true
                '''
            }
        }

        stage('Deploy Shared RabbitMQ Infrastructure') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh """
                    echo "=========================================="
                    echo "Deploying Shared RabbitMQ Infrastructure"
                    echo "Environment: ${params.ENVIRONMENT}"
                    echo "=========================================="

                    ENVIRONMENT="${params.ENVIRONMENT}"
                    STACK_NAME="lms_shared_\${ENVIRONMENT}"

                    # Define environment-specific ports
                    case "\${ENVIRONMENT}" in
                        dev)
                            RABBITMQ_PORT=5672
                            RABBITMQ_MGMT_PORT=15672
                            VOLUME_NAME="rabbitmq_data_dev"
                            ;;
                        staging)
                            RABBITMQ_PORT=5673
                            RABBITMQ_MGMT_PORT=15673
                            VOLUME_NAME="rabbitmq_data_staging"
                            ;;
                        prod)
                            RABBITMQ_PORT=5674
                            RABBITMQ_MGMT_PORT=15674
                            VOLUME_NAME="rabbitmq_data_prod"
                            ;;
                        *)
                            echo "‚ùå ERROR: Unknown environment: \${ENVIRONMENT}"
                            exit 1
                            ;;
                    esac

                    echo "Environment: \${ENVIRONMENT}"
                    echo "Stack Name: \${STACK_NAME}"
                    echo "RabbitMQ Port: \${RABBITMQ_PORT}"
                    echo "RabbitMQ Management Port: \${RABBITMQ_MGMT_PORT}"
                    echo "Volume Name: \${VOLUME_NAME}"
                    echo ""

                    # Generate environment-specific docker-compose file
                    COMPOSE_FILE="${WORKSPACE}/docker-compose-rabbitmq-\${ENVIRONMENT}-generated.yml"

                    cat > "\${COMPOSE_FILE}" <<EOF
version: '3.8'

services:
  lms_shared_rabbitmq:
    image: rabbitmq:3-management
    restart: unless-stopped
    ports:
      - "\${RABBITMQ_PORT}:5672"
      - "\${RABBITMQ_MGMT_PORT}:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    volumes:
      - \${VOLUME_NAME}:/var/lib/rabbitmq
    networks:
      - lms_network
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 10s
      retries: 5
      timeout: 5s

networks:
  lms_network:
    external: true

volumes:
  \${VOLUME_NAME}:
EOF

                    echo "‚úÖ Generated compose file: \${COMPOSE_FILE}"
                    echo ""

                    # Check if lms_shared stack already exists
                    if docker stack ls | grep -q "\${STACK_NAME}"; then
                        echo "‚úÖ \${STACK_NAME} stack already deployed"
                        echo ""
                        echo "Current RabbitMQ service status:"
                        docker service ls --filter "name=\${STACK_NAME}" || echo "RabbitMQ service found"

                        echo ""
                        echo "Updating existing stack with new configuration..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 15 seconds for update to stabilize..."
                        sleep 15
                    else
                        echo "Deploying \${STACK_NAME} stack with RabbitMQ..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 30 seconds for RabbitMQ to start..."
                        sleep 30

                        echo ""
                        echo "Verifying RabbitMQ deployment:"
                        docker service ls --filter "name=\${STACK_NAME}"
                    fi

                    echo ""
                    echo "=========================================="
                    echo "‚úÖ RabbitMQ Infrastructure deployed for \${ENVIRONMENT}"
                    echo "   - Internal port: 5672 (for applications)"
                    echo "   - External port: \${RABBITMQ_PORT}"
                    echo "   - Management UI: http://localhost:\${RABBITMQ_MGMT_PORT}"
                    echo "   - Service name: \${STACK_NAME}_lms_shared_rabbitmq"
                    echo "   - DNS hostname: lms_shared_rabbitmq"
                    echo "=========================================="
                """
            }
        }

        stage('Deploy to Dev') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'dev' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm.yml ${STACK_NAME_DEV}

                        echo ""
                        echo "=========================================="
                        echo "VERIFYING DEPLOYMENT"
                        echo "=========================================="

                        echo "Waiting for services to stabilize..."
                        sleep 15

                        # List all services
                        echo "All services in stack:"
                        docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_DEV}"

                        echo ""
                        echo "Service replicas:"
                        docker stack services ${STACK_NAME_DEV}

                        echo "=========================================="
                    """
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm-staging.yml ${STACK_NAME_STAGING}

                        echo ""
                        echo "=========================================="
                        echo "VERIFYING DEPLOYMENT"
                        echo "=========================================="

                        echo "Waiting for services to stabilize..."
                        sleep 15

                        echo "Service replicas:"
                        docker stack services ${STACK_NAME_STAGING}

                        echo "=========================================="
                    """
                }
            }
        }

        stage('Manual Approval for Production') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                script {

        stage('Run K6 Load Tests (Staging)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.RUN_LOAD_TESTS == true }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        sh """
                            echo "=========================================="
                            echo "K6 LOAD TESTING - STAGING ENVIRONMENT"
                            echo "=========================================="
                            echo ""
                            echo "Testing scalability and system behavior under load"
                            echo "Comparing microservice performance metrics"
                            echo ""

                            # Wait for service to be fully ready
                            echo "Waiting 60 seconds for services to be fully ready..."
                            sleep 60

                            # Verify service is responding
                            echo "Verifying service health before load test..."
                            SERVICE_URL="http://localhost:8091"

                            MAX_RETRIES=10
                            RETRY_COUNT=0
                            while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
                                if curl -s -o /dev/null -w "%{http_code}" "\${SERVICE_URL}/actuator/health" | grep -q "200"; then
                                    echo "‚úÖ Service is healthy and ready for load testing"
                                    break
                                fi
                                echo "Waiting for service to be ready... (attempt \$((RETRY_COUNT + 1))/\$MAX_RETRIES)"
                                sleep 10
                                RETRY_COUNT=\$((RETRY_COUNT + 1))
                            done

                            if [ \$RETRY_COUNT -eq \$MAX_RETRIES ]; then
                                echo "‚ö†Ô∏è WARNING: Service health check failed, proceeding with caution"
                            fi

                            # Check if k6 is installed, if not use Docker
                            if command -v k6 &> /dev/null; then
                                echo "Using native k6 installation"
                                K6_CMD="k6"
                            else
                                echo "Using k6 via Docker"
                                K6_CMD="docker run --rm -i --network host -v \$(pwd)/k6:/scripts grafana/k6"
                            fi

                            echo ""
                            echo "=========================================="
                            echo "STARTING LOAD TEST"
                            echo "=========================================="
                            echo "Test Script: k6/quick-load-test.js"
                            echo "Target URL: \${SERVICE_URL}"
                            echo ""

                            # Record start time and initial replica count
                            INITIAL_REPLICAS=\$(docker service inspect ${STACK_NAME_STAGING}_lmslendings_command --format '{{.Spec.Mode.Replicated.Replicas}}' 2>/dev/null || echo "2")
                            echo "Initial replica count: \${INITIAL_REPLICAS}"
                            echo ""

                            # Run K6 load test
                            if command -v k6 &> /dev/null; then
                                k6 run --env BASE_URL=\${SERVICE_URL} --env ENVIRONMENT=staging k6/quick-load-test.js
                            else
                                docker run --rm -i --network host \\
                                    -v \$(pwd)/k6:/scripts \\
                                    -e BASE_URL=\${SERVICE_URL} \\
                                    -e ENVIRONMENT=staging \\
                                    grafana/k6 run /scripts/quick-load-test.js
                            fi

                            echo ""
                            echo "=========================================="
                            echo "LOAD TEST COMPLETED"
                            echo "=========================================="

                            # Display current service metrics after load test
                            echo ""
                            echo "Service status after load test:"
                            docker stack services ${STACK_NAME_STAGING}

                            echo ""
                            echo "Container resource usage:"
                            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" \$(docker ps -q --filter "label=com.docker.stack.namespace=${STACK_NAME_STAGING}") 2>/dev/null || echo "Stats not available"

                            echo ""
                            echo "=========================================="
                            echo "MICROSERVICE VS MONOLITH COMPARISON"
                            echo "=========================================="
                            echo ""
                            echo "Microservice Architecture Benefits Demonstrated:"
                            echo "  ‚úì Independent scaling of lendings service"
                            echo "  ‚úì Isolated failure domain"
                            echo "  ‚úì Resource efficiency per service"
                            echo "  ‚úì Multiple instances handling concurrent load"
                            echo ""
                            echo "Current deployment:"
                            echo "  - Replicas: \${INITIAL_REPLICAS}"
                            echo "  - Load balanced across instances"
                            echo "  - Each instance handles portion of traffic"
                            echo ""
                            echo "In a monolith architecture:"
                            echo "  - Would need to scale entire application"
                            echo "  - All modules share same resources"
                            echo "  - Single point of failure"
                            echo "  - Less efficient resource utilization"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Auto-Scale Based on Load Test Results') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                    expression { params.RUN_LOAD_TESTS == true }
                    expression { params.AUTO_SCALE == true }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        sh """
                            echo "=========================================="
                            echo "AUTO-SCALING BASED ON LOAD TEST RESULTS"
                            echo "=========================================="
                            echo ""

                            SERVICE_NAME="${STACK_NAME_STAGING}_lmslendings_command"

                            # Get current replica count
                            CURRENT_REPLICAS=\$(docker service inspect \${SERVICE_NAME} --format '{{.Spec.Mode.Replicated.Replicas}}' 2>/dev/null || echo "2")
                            echo "Current replica count: \${CURRENT_REPLICAS}"

                            # Read load test results if available
                            if [ -f "load-test-results.json" ]; then
                                echo "Reading load test results..."

                                # Parse JSON results using jq or grep
                                if command -v jq &> /dev/null; then
                                    SCALING_ACTION=\$(jq -r '.scalingRecommendation.action' load-test-results.json)
                                    RECOMMENDED_REPLICAS=\$(jq -r '.scalingRecommendation.recommendedReplicas' load-test-results.json)
                                    P95_LATENCY=\$(jq -r '.metrics.http_req_duration_p95' load-test-results.json)
                                    ERROR_RATE=\$(jq -r '.metrics.http_req_failed' load-test-results.json)
                                else
                                    # Fallback parsing without jq
                                    SCALING_ACTION=\$(grep -o '"action":"[^"]*"' load-test-results.json | cut -d'"' -f4 || echo "MAINTAIN")
                                    RECOMMENDED_REPLICAS=\$(grep -o '"recommendedReplicas":[0-9]*' load-test-results.json | cut -d':' -f2 || echo "2")
                                    P95_LATENCY="N/A"
                                    ERROR_RATE="N/A"
                                fi

                                echo ""
                                echo "Load Test Metrics:"
                                echo "  - P95 Latency: \${P95_LATENCY} ms"
                                echo "  - Error Rate: \${ERROR_RATE}"
                                echo "  - Scaling Action: \${SCALING_ACTION}"
                                echo "  - Recommended Replicas: \${RECOMMENDED_REPLICAS}"
                            else
                                echo "‚ö†Ô∏è Load test results file not found"
                                echo "Using default scaling logic based on service metrics..."

                                # Default scaling logic based on resource usage
                                CPU_USAGE=\$(docker stats --no-stream --format "{{.CPUPerc}}" \$(docker ps -q --filter "label=com.docker.swarm.service.name=\${SERVICE_NAME}" | head -1) 2>/dev/null | tr -d '%' || echo "0")

                                if [ "\${CPU_USAGE%.*}" -gt 80 ]; then
                                    SCALING_ACTION="SCALE_UP"
                                    RECOMMENDED_REPLICAS=\$((CURRENT_REPLICAS + 1))
                                elif [ "\${CPU_USAGE%.*}" -lt 20 ] && [ "\${CURRENT_REPLICAS}" -gt 1 ]; then
                                    SCALING_ACTION="SCALE_DOWN"
                                    RECOMMENDED_REPLICAS=\$((CURRENT_REPLICAS - 1))
                                else
                                    SCALING_ACTION="MAINTAIN"
                                    RECOMMENDED_REPLICAS=\${CURRENT_REPLICAS}
                                fi

                                echo "CPU Usage: \${CPU_USAGE}%"
                            fi

                            echo ""
                            echo "=========================================="
                            echo "SCALING DECISION"
                            echo "=========================================="

                            # Apply scaling based on recommendation
                            case "\${SCALING_ACTION}" in
                                SCALE_UP)
                                    if [ "\${RECOMMENDED_REPLICAS}" -gt "\${CURRENT_REPLICAS}" ]; then
                                        echo "üìà SCALING UP: \${CURRENT_REPLICAS} ‚Üí \${RECOMMENDED_REPLICAS} replicas"
                                        echo ""
                                        echo "Executing: docker service scale \${SERVICE_NAME}=\${RECOMMENDED_REPLICAS}"
                                        docker service scale \${SERVICE_NAME}=\${RECOMMENDED_REPLICAS}

                                        echo ""
                                        echo "Waiting for scaling to complete..."
                                        sleep 30

                                        # Verify scaling
                                        NEW_REPLICAS=\$(docker service inspect \${SERVICE_NAME} --format '{{.Spec.Mode.Replicated.Replicas}}')
                                        echo "‚úÖ Scaling completed: \${NEW_REPLICAS} replicas now running"
                                    else
                                        echo "‚ÑπÔ∏è Already at or above recommended replicas (\${CURRENT_REPLICAS})"
                                    fi
                                    ;;
                                SCALE_DOWN)
                                    if [ "\${RECOMMENDED_REPLICAS}" -lt "\${CURRENT_REPLICAS}" ] && [ "\${RECOMMENDED_REPLICAS}" -ge 1 ]; then
                                        echo "üìâ SCALING DOWN: \${CURRENT_REPLICAS} ‚Üí \${RECOMMENDED_REPLICAS} replicas"
                                        echo ""
                                        echo "Executing: docker service scale \${SERVICE_NAME}=\${RECOMMENDED_REPLICAS}"
                                        docker service scale \${SERVICE_NAME}=\${RECOMMENDED_REPLICAS}

                                        echo ""
                                        echo "Waiting for scaling to complete..."
                                        sleep 20

                                        # Verify scaling
                                        NEW_REPLICAS=\$(docker service inspect \${SERVICE_NAME} --format '{{.Spec.Mode.Replicated.Replicas}}')
                                        echo "‚úÖ Scaling completed: \${NEW_REPLICAS} replicas now running"
                                    else
                                        echo "‚ÑπÔ∏è Minimum replicas reached or no scaling needed (\${CURRENT_REPLICAS})"
                                    fi
                                    ;;
                                MAINTAIN|*)
                                    echo "‚û°Ô∏è MAINTAINING current replica count: \${CURRENT_REPLICAS}"
                                    echo "Performance metrics are within acceptable thresholds"
                                    ;;
                            esac

                            echo ""
                            echo "=========================================="
                            echo "POST-SCALING SERVICE STATUS"
                            echo "=========================================="
                            docker stack services ${STACK_NAME_STAGING}

                            echo ""
                            echo "Service tasks:"
                            docker service ps \${SERVICE_NAME} --format "table {{.Name}}\t{{.CurrentState}}\t{{.Node}}"

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Auto-scaling stage completed"
                            echo "=========================================="
                        """
                    }
                }
            }
        }
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Post-Deployment Verification') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                script {
                    def stackName = params.ENVIRONMENT == 'dev' ? env.STACK_NAME_DEV :
                                   (params.ENVIRONMENT == 'staging' ? env.STACK_NAME_STAGING : env.STACK_NAME_PROD)

                    sh """
                        echo "=========================================="
                        echo "POST-DEPLOYMENT VERIFICATION"
                        echo "Environment: ${params.ENVIRONMENT}"
                        echo "=========================================="

                        # Wait for Docker Swarm to update replica status
                        echo ""
                        echo "Waiting 15 seconds for Docker Swarm to update replica status..."
                        sleep 15

                        echo ""
                        echo "Current service status:"
                        docker stack services ${stackName}

                        echo ""
                        echo "Service tasks:"
                        docker stack ps ${stackName} --no-trunc

                        echo ""
                        echo "=========================================="
                    """

                    // Show health checks for production only
                    if (params.ENVIRONMENT == 'prod') {
                        sh """
                            echo ""
                            echo "=========================================="
                            echo "POST-DEPLOYMENT HEALTH CHECK VERIFICATION"
                            echo "=========================================="

                            # Wait a bit for health checks to stabilize
                            echo "Waiting 30 seconds for health checks to stabilize..."
                            sleep 30

                            # Check each service
                            for SERVICE in \$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}"); do
                                echo ""
                                echo "Checking health of: \$SERVICE"
                                echo "----------------------------------------"

                                # Get task IDs
                                TASKS=\$(docker service ps \$SERVICE --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)

                                for TASK in \$TASKS; do
                                    CONTAINER_ID=\$(docker inspect \$TASK --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")

                                    if [ -n "\$CONTAINER_ID" ]; then
                                        HEALTH=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "none")
                                        TASK_NAME=\$(docker inspect \$TASK --format "{{.Name}}" 2>/dev/null)

                                        if [ "\$HEALTH" = "healthy" ]; then
                                            echo "  ‚úÖ \$TASK_NAME: HEALTHY"
                                        elif [ "\$HEALTH" = "unhealthy" ]; then
                                            echo "  ‚ùå \$TASK_NAME: UNHEALTHY"
                                        elif [ "\$HEALTH" = "starting" ]; then
                                            echo "  üîÑ \$TASK_NAME: STARTING (health checks in progress)"
                                        else
                                            echo "  ‚ÑπÔ∏è  \$TASK_NAME: No health check configured"
                                        fi
                                    fi
                                done
                            done

                            echo ""
                            echo "=========================================="
                            echo "‚úÖ Post-deployment verification completed"
                            echo "=========================================="
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                echo "=========================================="
                echo "Pipeline completed successfully!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "SUCCESS: LMS Lendings Command - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Successful</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Image Tag:</strong> ${IMAGE_TAG}</p>
                            <p><strong>Status:</strong> ‚úÖ SUCCESS</p>
                            <br>
                            <p><a href="${BUILD_URL}">View Build Details</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "‚úÖ Success notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "‚ö†Ô∏è WARNING: Could not send success email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }

        failure {
            script {
                echo "=========================================="
                echo "Pipeline failed!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "FAILURE: LMS Lendings Command - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Failed</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Image Tag:</strong> ${IMAGE_TAG}</p>
                            <p><strong>Status:</strong> ‚ùå FAILURE</p>
                            <br>
                            <p><a href="${BUILD_URL}console">View Console Output</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "‚úÖ Failure notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "‚ö†Ô∏è WARNING: Could not send failure email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }

        always {
            echo "=========================================="
            echo "Pipeline execution completed"
            echo "=========================================="
        }
    }
}


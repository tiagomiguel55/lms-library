pipeline {
    agent any

    environment {
        // Maven and Java
        MAVEN_HOME = '/usr/share/maven'
        JAVA_HOME  = '/usr/lib/jvm/java-17-openjdk-amd64'

        // Git
        GIT_REPO_URL   = 'https://github.com/tiagomiguel55/lms-library.git'
        GIT_BRANCH    = 'main'
        CREDENTIALS_ID = 'password_for_github_tiago'

        // Docker Registry
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_REGISTRY_CREDENTIALS = 'dockerhub-credentials'
        DOCKER_REGISTRY_NAMESPACE = 'tiagomiguel55'

        // Docker
        IMAGE_NAME = 'lmsbooks-query'
        IMAGE_TAG  = "${GIT_COMMIT}"
        FULL_IMAGE_NAME = "${DOCKER_REGISTRY}/${DOCKER_REGISTRY_NAMESPACE}/${IMAGE_NAME}"

        // Swarm stacks
        STACK_NAME_DEV     = 'lmsbooks-query-dev'
        STACK_NAME_STAGING = 'lmsbooks-query-staging'
        STACK_NAME_PROD    = 'lmsbooks-query-prod'

        // Email
        EMAIL_RECIPIENT = 'migueltiago255@gmail.com'

        // Working directory
        WORK_DIR = 'P2/lms_books_query'
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Deployment environment'
        )
        booleanParam(
            name: 'SKIP_DEPLOY',
            defaultValue: false,
            description: 'Skip deployment'
        )
    }

    stages {

        stage('Checkout') {
            steps {
                git branch: "${GIT_BRANCH}",
                    url: "${GIT_REPO_URL}",
                    credentialsId: "${CREDENTIALS_ID}"
            }
        }

        stage('Static Analysis') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Run static analysis in dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "Running Static Code Analysis"
                        echo "Tools: Checkstyle, SpotBugs, PMD"
                        echo "=========================================="
                        
                        // Run Checkstyle
                        echo ""
                        echo "Running Checkstyle..."
                        sh """
                            ${MAVEN_HOME}/bin/mvn checkstyle:checkstyle -DskipTests || true
                        """
                        
                        // Run SpotBugs
                        echo ""
                        echo "Running SpotBugs..."
                        sh """
                            ${MAVEN_HOME}/bin/mvn compile spotbugs:spotbugs -DskipTests || true
                        """
                        
                        // Run PMD
                        echo ""
                        echo "Running PMD..."
                        sh """
                            ${MAVEN_HOME}/bin/mvn pmd:pmd -DskipTests || true
                        """
                        
                        echo ""
                        echo "=========================================="
                        echo "✅ Static Analysis Completed"
                        echo "Reports generated in target/ directory:"
                        echo "  - Checkstyle: target/checkstyle-result.xml"
                        echo "  - SpotBugs: target/spotbugsXml.xml"
                        echo "  - PMD: target/pmd.xml"
                        echo "=========================================="
                    }
                }
            }
            post {
                always {
                    dir("${WORK_DIR}") {
                        // Archive static analysis reports
                        archiveArtifacts artifacts: 'target/checkstyle-result.xml,target/spotbugsXml.xml,target/pmd.xml,target/site/**', allowEmptyArchive: true
                        
                        // Publish Checkstyle report
                        recordIssues(
                            enabledForFailure: true, 
                            tools: [checkStyle(pattern: 'target/checkstyle-result.xml')]
                        )
                        
                        // Publish SpotBugs report
                        recordIssues(
                            enabledForFailure: true,
                            tools: [spotBugs(pattern: 'target/spotbugsXml.xml')]
                        )
                        
                        // Publish PMD report
                        recordIssues(
                            enabledForFailure: true,
                            tools: [pmdParser(pattern: 'target/pmd.xml')]
                        )
                    }
                }
            }
        }

        stage('Unit & Integration Tests') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Run tests in dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "Running Unit Tests and Integration Tests"
                        echo "=========================================="
                        
                        // Run unit tests and integration tests
                        sh """
                            ${MAVEN_HOME}/bin/mvn clean test -DskipIntegrationTests=false || true
                        """
                        
                        echo ""
                        echo "=========================================="
                        echo "✅ Unit & Integration Tests Completed"
                        echo "Reports generated in target/surefire-reports/"
                        echo "=========================================="
                    }
                }
            }
            post {
                always {
                    dir("${WORK_DIR}") {
                        // Archive test reports
                        archiveArtifacts artifacts: 'target/surefire-reports/**,target/failsafe-reports/**', allowEmptyArchive: true
                        
                        // Publish JUnit test results
                        junit 'target/surefire-reports/**/*.xml'
                    }
                }
            }
        }

        stage('Consumer-Driven Contract Tests') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Run CDC tests in dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "Running Consumer-Driven Contract (PACT) Tests"
                        echo "=========================================="
                        
                        // Run PACT tests (CDC provider and consumer tests)
                        sh """
                            ${MAVEN_HOME}/bin/mvn test -Dtest='**/CDC/**/*IT' -DfailIfNoTests=false || true
                        """
                        
                        echo ""
                        echo "=========================================="
                        echo "✅ Consumer-Driven Contract Tests Completed"
                        echo "PACT files generated in target/pacts/"
                        echo "=========================================="
                    }
                }
            }
            post {
                always {
                    dir("${WORK_DIR}") {
                        // Archive PACT contract files
                        archiveArtifacts artifacts: 'target/pacts/**', allowEmptyArchive: true
                        
                        // Publish test reports
                        junit 'target/surefire-reports/**/*.xml', allowEmptyResults: true
                    }
                }
            }
        }

        stage('Mutation Tests') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Run mutation tests in dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "Running Mutation Tests (PITest)"
                        echo "=========================================="
                        
                        // Run mutation testing with PITest
                        sh """
                            ${MAVEN_HOME}/bin/mvn org.pitest:pitest-maven:mutationCoverage || true
                        """
                        
                        echo ""
                        echo "=========================================="
                        echo "✅ Mutation Testing Completed"
                        echo "Reports generated in target/pit-reports/"
                        echo "=========================================="
                    }
                }
            }
            post {
                always {
                    dir("${WORK_DIR}") {
                        // Archive PITest mutation reports
                        archiveArtifacts artifacts: 'target/pit-reports/**', allowEmptyArchive: true
                        
                        // Publish PITest HTML report
                        publishHTML([
                            allowMissing: true,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'target/pit-reports',
                            reportFiles: 'index.html',
                            reportName: 'PITest Mutation Report'
                        ])
                    }
                }
            }
        }

        stage('Build & Package') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Build apenas em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        ${MAVEN_HOME}/bin/mvn clean package -DskipTests
                    """
                }
            }
        }

        stage('Build Docker Image') {
            when {
                expression { params.ENVIRONMENT != 'prod' } // Build apenas em dev/staging
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
                        docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${params.ENVIRONMENT}
                    """
                }
            }
        }

        stage('Push Docker Image to Registry') {
            when {
                expression { params.ENVIRONMENT == 'dev' || params.ENVIRONMENT == 'staging' }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pushing image to registry..."
                            echo "Environment: ${params.ENVIRONMENT}"
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Namespace: ${DOCKER_REGISTRY_NAMESPACE}"
                            echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Tagging for registry..."
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "Pushing image..."
                            docker push ${FULL_IMAGE_NAME}:${IMAGE_TAG}
                            docker push ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}

                            echo ""
                            echo "=========================================="
                            echo "✅ Image pushed to registry!"
                            echo "   ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   ${FULL_IMAGE_NAME}:${params.ENVIRONMENT}"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Pull Docker Image from Registry') {
            when {
                expression { params.ENVIRONMENT == 'prod' } // Prod faz pull da imagem de staging
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: "${DOCKER_REGISTRY_CREDENTIALS}", usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                            echo "=========================================="
                            echo "Pulling image from registry for Production..."
                            echo "Registry: ${DOCKER_REGISTRY}"
                            echo "Image: ${FULL_IMAGE_NAME}:${IMAGE_TAG}"
                            echo "=========================================="

                            echo "\$DOCKER_PASSWORD" | docker login ${DOCKER_REGISTRY} -u "\$DOCKER_USERNAME" --password-stdin

                            echo ""
                            echo "Pulling image..."
                            docker pull ${FULL_IMAGE_NAME}:${IMAGE_TAG}

                            echo ""
                            echo "Tagging as prod and local name..."
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:${IMAGE_TAG}
                            docker tag ${FULL_IMAGE_NAME}:${IMAGE_TAG} ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "Pushing prod tag to registry..."
                            docker push ${FULL_IMAGE_NAME}:prod

                            echo ""
                            echo "=========================================="
                            echo "✅ Production image ready!"
                            echo "   Local: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "   Registry: ${FULL_IMAGE_NAME}:prod"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Initialize Docker Swarm') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh '''
                    set -e

                    # Initialize Docker Swarm if not already initialized
                    docker info | grep -q "Swarm: active" || docker swarm init || true

                    echo "Checking for lms_network..."

                    # Check if lms_network exists
                    if docker network ls --format '{{.Name}}' | grep -q '^lms_network$'; then
                        echo "Network 'lms_network' found. Inspecting..."

                        # Get network details
                        NETWORK_INFO=$(docker network inspect lms_network 2>/dev/null || echo "")

                        if [ -n "$NETWORK_INFO" ]; then
                            # Extract scope and driver using grep and cut
                            NETWORK_SCOPE=$(echo "$NETWORK_INFO" | grep '"Scope":' | head -1 | cut -d'"' -f4)
                            NETWORK_DRIVER=$(echo "$NETWORK_INFO" | grep '"Driver":' | head -1 | cut -d'"' -f4)

                            echo "Network scope: $NETWORK_SCOPE"
                            echo "Network driver: $NETWORK_DRIVER"

                            # If network is local scope, remove it and create overlay
                            if [ "$NETWORK_SCOPE" = "local" ]; then
                                echo "Removing local network 'lms_network'..."
                                docker network rm lms_network || true
                                sleep 2

                                echo "Creating overlay network 'lms_network'..."
                                docker network create --driver overlay --attachable lms_network
                            elif [ "$NETWORK_DRIVER" != "overlay" ]; then
                                echo "Network exists but is not overlay type. Removing and recreating..."
                                docker network rm lms_network || true
                                sleep 2

                                echo "Creating overlay network 'lms_network'..."
                                docker network create --driver overlay --attachable lms_network
                            else
                                echo "✅ Network 'lms_network' already exists as overlay network"
                            fi
                        else
                            echo "Could not inspect network. Creating new overlay network..."
                            docker network create --driver overlay --attachable lms_network || true
                        fi
                    else
                        echo "Network 'lms_network' does not exist. Creating overlay network..."
                        docker network create --driver overlay --attachable lms_network
                    fi

                    # Final verification
                    echo ""
                    echo "Final network verification:"
                    docker network ls | grep lms_network || echo "Network not found!"
                    docker network inspect lms_network --format 'Name: {{.Name}}, Driver: {{.Driver}}, Scope: {{.Scope}}' || echo "Inspection failed"

                    echo ""
                    echo "✅ Network initialization completed"
                '''
            }
        }

        stage('Deploy Shared RabbitMQ Infrastructure') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                sh """
                    echo "=========================================="
                    echo "Deploying Shared RabbitMQ Infrastructure"
                    echo "Environment: ${params.ENVIRONMENT}"
                    echo "=========================================="

                    ENVIRONMENT="${params.ENVIRONMENT}"
                    STACK_NAME="lms_shared_\${ENVIRONMENT}"

                    # Define environment-specific ports
                    case "\${ENVIRONMENT}" in
                        dev)
                            RABBITMQ_PORT=5672
                            RABBITMQ_MGMT_PORT=15672
                            VOLUME_NAME="rabbitmq_data_dev"
                            ;;
                        staging)
                            RABBITMQ_PORT=5673
                            RABBITMQ_MGMT_PORT=15673
                            VOLUME_NAME="rabbitmq_data_staging"
                            ;;
                        prod)
                            RABBITMQ_PORT=5674
                            RABBITMQ_MGMT_PORT=15674
                            VOLUME_NAME="rabbitmq_data_prod"
                            ;;
                        *)
                            echo "❌ ERROR: Unknown environment: \${ENVIRONMENT}"
                            exit 1
                            ;;
                    esac

                    echo "Environment: \${ENVIRONMENT}"
                    echo "Stack Name: \${STACK_NAME}"
                    echo "RabbitMQ Port: \${RABBITMQ_PORT}"
                    echo "RabbitMQ Management Port: \${RABBITMQ_MGMT_PORT}"
                    echo "Volume Name: \${VOLUME_NAME}"
                    echo ""

                    # Generate environment-specific docker-compose file
                    COMPOSE_FILE="${WORKSPACE}/docker-compose-rabbitmq-\${ENVIRONMENT}-generated.yml"

                    cat > "\${COMPOSE_FILE}" <<EOF
version: '3.8'

services:
  lms_shared_rabbitmq:
    image: rabbitmq:3-management
    restart: unless-stopped
    ports:
      - "\${RABBITMQ_PORT}:5672"
      - "\${RABBITMQ_MGMT_PORT}:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    volumes:
      - \${VOLUME_NAME}:/var/lib/rabbitmq
    networks:
      - lms_network
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 10s
      retries: 5
      timeout: 5s

networks:
  lms_network:
    external: true

volumes:
  \${VOLUME_NAME}:
EOF

                    echo "✅ Generated compose file: \${COMPOSE_FILE}"
                    echo ""
                    echo "Content:"
                    cat "\${COMPOSE_FILE}"
                    echo ""

                    # Check if lms_shared stack already exists
                    if docker stack ls | grep -q "\${STACK_NAME}"; then
                        echo "✅ \${STACK_NAME} stack already deployed"
                        echo ""
                        echo "Current RabbitMQ service status:"
                        docker service ls --filter "name=\${STACK_NAME}" || echo "RabbitMQ service found"

                        echo ""
                        echo "Updating existing stack with new configuration..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 15 seconds for update to stabilize..."
                        sleep 15
                    else
                        echo "Deploying \${STACK_NAME} stack with RabbitMQ..."
                        docker stack deploy -c "\${COMPOSE_FILE}" \${STACK_NAME}

                        echo "Waiting 30 seconds for RabbitMQ to start..."
                        sleep 30

                        echo ""
                        echo "Verifying RabbitMQ deployment:"
                        docker service ls --filter "name=\${STACK_NAME}"
                    fi

                    echo ""
                    echo "RabbitMQ service full name:"
                    docker service ls | grep "\${STACK_NAME}" || echo "No RabbitMQ found for \${STACK_NAME}"

                    echo ""
                    echo "RabbitMQ service details:"
                    docker service ps "\${STACK_NAME}_lms_shared_rabbitmq" --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "Service is starting..."

                    echo ""
                    echo "=========================================="
                    echo "✅ RabbitMQ Infrastructure deployed for \${ENVIRONMENT}"
                    echo "   - Internal port: 5672 (for applications)"
                    echo "   - External port: \${RABBITMQ_PORT}"
                    echo "   - Management UI: http://localhost:\${RABBITMQ_MGMT_PORT}"
                    echo "   - Service name: \${STACK_NAME}_lms_shared_rabbitmq"
                    echo "   - DNS hostname: lms_shared_rabbitmq"
                    echo "=========================================="
                """
            }
        }

        stage('Deploy to Dev') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'dev' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm.yml ${STACK_NAME_DEV}

                        echo ""
                        echo "=========================================="
                        echo "VERIFYING RABBITMQ CONNECTIVITY"
                        echo "=========================================="

                        # List all services
                        echo "All services:"
                        docker service ls

                        echo ""
                        echo "Services on lms_network:"
                        docker network inspect lms_network --format '{{range .Services}}{{.Name}} {{end}}' || echo "Could not inspect network services"

                        echo ""
                        echo "Looking for RabbitMQ service..."
                        docker service ls | grep rabbitmq || echo "No RabbitMQ service found!"

                        echo ""
                        echo "Checking if RabbitMQ service from dev stack exists:"
                        docker service inspect ${STACK_NAME_DEV}_rabbitmq_dev 2>/dev/null && echo "✅ RabbitMQ service exists" || echo "❌ RabbitMQ service NOT FOUND"

                        echo ""
                        echo "RabbitMQ service details:"
                        docker service ps ${STACK_NAME_DEV}_rabbitmq_dev --format "{{.Name}}: {{.CurrentState}}" 2>/dev/null || echo "Could not get RabbitMQ status"

                        echo ""
                        echo "Testing DNS resolution from query service..."
                        sleep 15

                        # Get a query service task/container
                        QUERY_TASK=\$(docker service ps ${STACK_NAME_DEV}_lmsbooks_query --filter "desired-state=running" --format "{{.Name}}.{{.ID}}" 2>/dev/null | head -1)

                        if [ -n "\$QUERY_TASK" ]; then
                            echo "Testing from task: \$QUERY_TASK"
                            echo "Attempting to resolve rabbitmq_dev hostname..."
                            docker exec \$QUERY_TASK nslookup rabbitmq_dev 2>/dev/null || echo "DNS lookup for rabbitmq_dev failed"
                            docker exec \$QUERY_TASK ping -c 2 rabbitmq_dev 2>/dev/null || echo "Ping to rabbitmq_dev failed"
                        else
                            echo "Could not find running query task"
                        fi

                        echo "=========================================="
                    """
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    sh """
                        export IMAGE_TAG=${IMAGE_TAG}
                        docker stack deploy -c docker-compose-swarm-staging.yml ${STACK_NAME_STAGING}
                    """
                }
            }
        }

        stage('Load Tests - K6 (Staging)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "K6 LOAD TESTS - STAGING ENVIRONMENT"
                        echo "=========================================="
                        echo "Testing read performance with GET /api/books/{isbn}"
                        echo "Demonstrating scalability with multiple instances"
                        echo "=========================================="

                        sh """
                            # Wait for staging services to be fully ready
                            echo "Waiting 60 seconds for staging services to stabilize..."
                            sleep 60

                            # Verify service is running
                            echo ""
                            echo "Verifying staging service status..."
                            docker service ls --filter "name=${STACK_NAME_STAGING}"

                            # Get the staging service URL - using VM IP
                            STAGING_PORT=8086
                            VM_IP="74.161.33.56"
                            SERVICE_URL="http://\${VM_IP}:\${STAGING_PORT}"

                            echo ""
                            echo "Service URL: \${SERVICE_URL}"

                            echo ""
                            echo "K6 version:"
                            k6 version

                            echo ""
                            echo "=========================================="
                            echo "STARTING K6 LOAD TESTS"
                            echo "=========================================="
                            echo ""

                            # Run k6 load tests
                            export SERVICE_URL="\${SERVICE_URL}"
                            export MONOLITH_BASELINE_RPS=50

                            k6 run \\
                                --out json=/tmp/k6_metrics_query.json \\
                                --summary-export=/tmp/k6_summary_query.json \\
                                -e SERVICE_URL=\${SERVICE_URL} \\
                                -e MONOLITH_BASELINE_RPS=\${MONOLITH_BASELINE_RPS} \\
                                load-test.js

                            K6_EXIT_CODE=\$?

                            echo ""
                            echo "=========================================="
                            echo "K6 LOAD TEST COMPLETED"
                            echo "=========================================="

                            # Display results summary
                            if [ -f /tmp/load_test_results.json ]; then
                                echo ""
                                echo "Load Test Results:"
                                cat /tmp/load_test_results.json
                            fi

                            # Check thresholds
                            if [ \$K6_EXIT_CODE -ne 0 ]; then
                                echo ""
                                echo "⚠️ WARNING: Some K6 thresholds were not met"
                                echo "This may trigger auto-scaling in the next stage"
                            else
                                echo ""
                                echo "✅ All K6 thresholds passed"
                            fi

                            echo ""
                            echo "=========================================="
                            echo "LOAD TEST METRICS SUMMARY"
                            echo "=========================================="

                            if [ -f /tmp/load_test_results.json ]; then
                                # Extract and display key metrics
                                if command -v jq &> /dev/null; then
                                    echo "Success Rate:          \$(jq -r '.results.success_rate' /tmp/load_test_results.json)%"
                                    echo "Requests per Second:   \$(jq -r '.results.requests_per_second' /tmp/load_test_results.json) RPS"
                                    echo "Avg Response Time:     \$(jq -r '.results.response_time_ms.average' /tmp/load_test_results.json) ms"
                                    echo "P95 Response Time:     \$(jq -r '.results.response_time_ms.p95' /tmp/load_test_results.json) ms"
                                    echo ""
                                    echo "Monolith Baseline:     \$(jq -r '.comparison.monolith_baseline_rps' /tmp/load_test_results.json) RPS"
                                    echo "Performance Diff:      \$(jq -r '.comparison.performance_improvement_percent' /tmp/load_test_results.json)%"
                                    echo ""
                                    echo "Scaling Recommendation: \$(jq -r '.scaling.recommendation' /tmp/load_test_results.json)"
                                    echo "Recommended Replicas:   \$(jq -r '.scaling.recommended_replicas' /tmp/load_test_results.json)"
                                else
                                    cat /tmp/load_test_results.json
                                fi
                            fi

                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Auto-Scale Based on Load Tests (Staging)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'staging' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "=========================================="
                        echo "AUTO-SCALING BASED ON LOAD TEST RESULTS"
                        echo "=========================================="

                        sh """
                            echo "Reading load test results and determining scaling action..."
                            echo ""

                            # Set variables for auto-scale script
                            export SERVICE_NAME="${STACK_NAME_STAGING}_lmsbooks_query"
                            export RESULTS_FILE="/tmp/load_test_results.json"
                            export MIN_REPLICAS=1
                            export MAX_REPLICAS=5

                            # Check if results file exists
                            if [ ! -f "\${RESULTS_FILE}" ]; then
                                echo "⚠️ Load test results not found. Skipping auto-scaling."
                                exit 0
                            fi

                            echo "=========================================="
                            echo "CURRENT SERVICE STATUS"
                            echo "=========================================="
                            docker service ls --filter "name=\${SERVICE_NAME}" || echo "Service not found with exact name"

                            # Try to find the service
                            ACTUAL_SERVICE=\$(docker service ls --format "{{.Name}}" | grep -E "query.*staging|staging.*query" | head -1 || echo "")

                            if [ -z "\$ACTUAL_SERVICE" ]; then
                                echo "Looking for any staging query service..."
                                ACTUAL_SERVICE=\$(docker service ls --filter "name=${STACK_NAME_STAGING}" --format "{{.Name}}" | head -1 || echo "")
                            fi

                            if [ -n "\$ACTUAL_SERVICE" ]; then
                                export SERVICE_NAME="\$ACTUAL_SERVICE"
                                echo "Found service: \$SERVICE_NAME"
                            fi

                            echo ""
                            echo "=========================================="
                            echo "LOAD TEST RESULTS ANALYSIS"
                            echo "=========================================="

                            # Read scaling recommendation from results
                            if command -v jq &> /dev/null; then
                                RECOMMENDATION=\$(jq -r '.scaling.recommendation' "\${RESULTS_FILE}")
                                RECOMMENDED_REPLICAS=\$(jq -r '.scaling.recommended_replicas' "\${RESULTS_FILE}")
                                SUCCESS_RATE=\$(jq -r '.results.success_rate' "\${RESULTS_FILE}")
                                RPS=\$(jq -r '.results.requests_per_second' "\${RESULTS_FILE}")
                                AVG_RESPONSE=\$(jq -r '.results.response_time_ms.average' "\${RESULTS_FILE}")
                            else
                                RECOMMENDATION=\$(python3 -c "import json; print(json.load(open('\${RESULTS_FILE}'))['scaling']['recommendation'])")
                                RECOMMENDED_REPLICAS=\$(python3 -c "import json; print(json.load(open('\${RESULTS_FILE}'))['scaling']['recommended_replicas'])")
                                SUCCESS_RATE=\$(python3 -c "import json; print(json.load(open('\${RESULTS_FILE}'))['results']['success_rate'])")
                                RPS=\$(python3 -c "import json; print(json.load(open('\${RESULTS_FILE}'))['results']['requests_per_second'])")
                                AVG_RESPONSE=\$(python3 -c "import json; print(json.load(open('\${RESULTS_FILE}'))['results']['response_time_ms']['average'])")
                            fi

                            echo "Success Rate:          \${SUCCESS_RATE}%"
                            echo "Requests/Second:       \${RPS} RPS"
                            echo "Avg Response Time:     \${AVG_RESPONSE} ms"
                            echo "Recommendation:        \${RECOMMENDATION}"
                            echo "Recommended Replicas:  \${RECOMMENDED_REPLICAS}"

                            # Get current replicas
                            CURRENT_REPLICAS=\$(docker service inspect "\${SERVICE_NAME}" --format '{{.Spec.Mode.Replicated.Replicas}}' 2>/dev/null || echo "2")
                            echo ""
                            echo "Current Replicas:      \${CURRENT_REPLICAS}"

                            echo ""
                            echo "=========================================="
                            echo "SCALING DECISION"
                            echo "=========================================="

                            TARGET_REPLICAS=\${CURRENT_REPLICAS}

                            if [ "\${RECOMMENDATION}" = "scale_up" ]; then
                                TARGET_REPLICAS=\${RECOMMENDED_REPLICAS}

                                # Enforce max replicas
                                if [ \${TARGET_REPLICAS} -gt \${MAX_REPLICAS} ]; then
                                    TARGET_REPLICAS=\${MAX_REPLICAS}
                                    echo "⚠️ Capping at max replicas: \${MAX_REPLICAS}"
                                fi

                                # Ensure we're actually scaling up
                                if [ \${TARGET_REPLICAS} -le \${CURRENT_REPLICAS} ]; then
                                    TARGET_REPLICAS=\$((CURRENT_REPLICAS + 1))
                                    if [ \${TARGET_REPLICAS} -gt \${MAX_REPLICAS} ]; then
                                        TARGET_REPLICAS=\${MAX_REPLICAS}
                                    fi
                                fi

                                echo "Action: SCALE UP"
                                echo "Reason: Load test metrics indicate need for more capacity"

                            elif [ "\${RECOMMENDATION}" = "scale_down" ]; then
                                TARGET_REPLICAS=\$((CURRENT_REPLICAS - 1))

                                # Enforce min replicas
                                if [ \${TARGET_REPLICAS} -lt \${MIN_REPLICAS} ]; then
                                    TARGET_REPLICAS=\${MIN_REPLICAS}
                                fi

                                echo "Action: SCALE DOWN"
                                echo "Reason: System is over-provisioned"

                            else
                                echo "Action: NO SCALING REQUIRED"
                                echo "Reason: Current capacity is optimal"
                            fi

                            echo ""
                            echo "Current Replicas:  \${CURRENT_REPLICAS}"
                            echo "Target Replicas:   \${TARGET_REPLICAS}"

                            echo ""
                            echo "=========================================="
                            echo "EXECUTING SCALING COMMAND"
                            echo "=========================================="

                            if [ \${TARGET_REPLICAS} -ne \${CURRENT_REPLICAS} ]; then
                                echo "Executing: docker service scale \${SERVICE_NAME}=\${TARGET_REPLICAS}"
                                echo ""

                                docker service scale "\${SERVICE_NAME}=\${TARGET_REPLICAS}"

                                echo ""
                                echo "Waiting 15 seconds for scaling to complete..."
                                sleep 15

                                echo ""
                                echo "=========================================="
                                echo "SCALING VERIFICATION"
                                echo "=========================================="

                                NEW_REPLICAS=\$(docker service inspect "\${SERVICE_NAME}" --format '{{.Spec.Mode.Replicated.Replicas}}')
                                RUNNING=\$(docker service ps "\${SERVICE_NAME}" --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null | wc -l)

                                echo "Desired Replicas:  \${NEW_REPLICAS}"
                                echo "Running Replicas:  \${RUNNING}"
                                echo ""

                                docker service ps "\${SERVICE_NAME}" --format "table {{.Name}}\t{{.CurrentState}}\t{{.Node}}" | head -10

                                echo ""
                                if [ \${RUNNING} -ge \${TARGET_REPLICAS} ]; then
                                    echo "✅ SCALING SUCCESSFUL"
                                    echo "Service \${SERVICE_NAME} scaled from \${CURRENT_REPLICAS} to \${TARGET_REPLICAS} replicas"
                                else
                                    echo "⚠️ Scaling in progress - some replicas still starting"
                                fi
                            else
                                echo "✅ No scaling action needed"
                                echo "Service already at optimal replica count (\${CURRENT_REPLICAS})"
                            fi

                            echo ""
                            echo "=========================================="
                            echo "FINAL SERVICE STATUS"
                            echo "=========================================="
                            docker service ls --filter "name=\${SERVICE_NAME}"

                            echo ""
                            echo "=========================================="
                            echo "AUTO-SCALING OPERATION COMPLETE"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Manual Approval for Production') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                script {
                    echo "=========================================="
                    echo "PRODUCTION DEPLOYMENT APPROVAL REQUIRED"
                    echo "=========================================="
                    echo "Project: LMS Books Query Service"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Image Tag: ${IMAGE_TAG}"
                    echo "Environment: PRODUCTION"
                    echo "Deployment Mode: Docker Swarm - Rolling Update (3 replicas)"
                    echo ""
                    echo "Rolling Update Strategy:"
                    echo "  - Update 1 container at a time"
                    echo "  - 10-second delay between updates"
                    echo "  - Health checks before proceeding"
                    echo "  - Automatic rollback on failure"
                    echo "=========================================="

                    try {
                        mail(
                            to: "${EMAIL_RECIPIENT}",
                            subject: "Jenkins: Production Deployment Approval Required - Build #${BUILD_NUMBER}",
                            body: """
                                Production Deployment Approval Required
                                =======================================

                                Project: LMS Books Query Service
                                Build Number: ${BUILD_NUMBER}
                                Image Tag: ${IMAGE_TAG}
                                Environment: PRODUCTION
                                Deployment Mode: Docker Swarm - Rolling Update (3 replicas)

                                Rolling Update Strategy:
                                - Update 1 container at a time
                                - 10-second delay between updates
                                - Health checks before proceeding
                                - Automatic rollback on failure

                                Please review and approve/reject the deployment to production.

                                Approve or reject at: ${BUILD_URL}input/

                                View full build details: ${BUILD_URL}
                            """,
                            mimeType: 'text/plain'
                        )
                        echo "✅ Email notification sent successfully to ${EMAIL_RECIPIENT}"
                    } catch (Exception e) {
                        echo "⚠️ WARNING: Could not send email notification"
                        echo "Email error: ${e.message}"
                        echo "Continuing with manual approval process..."
                    }

                    timeout(time: 30, unit: 'MINUTES') {
                        input message: 'Approve Production Deployment?', ok: 'Deploy'
                    }
                }
            }
        }

        stage('Deploy to Production (Rolling Update + Rollback)') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod' }
                    expression { params.SKIP_DEPLOY == false }
                }
            }
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "Starting PROD rolling update with image ${IMAGE_NAME}:${IMAGE_TAG}"

                        sh """
                            # Check if service already exists
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_query" --format "{{.Name}}" 2>/dev/null || echo "")

                            if [ -z "\$SERVICE_NAME" ]; then
                                echo "=========================================="
                                echo "⚠️ Service does not exist yet - First deployment"
                                echo "Creating stack for the first time..."
                                echo "=========================================="

                                # First deployment - just create the stack
                                export IMAGE_TAG=${IMAGE_TAG}
                                docker stack deploy -c docker-compose-swarm-prod.yml ${STACK_NAME_PROD}

                                echo "Waiting for services to start..."
                                sleep 30

                                # Get the newly created service name
                                SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_query" --format "{{.Name}}")

                                if [ -z "\$SERVICE_NAME" ]; then
                                    echo "❌ ERROR: Service was not created!"
                                    exit 1
                                fi

                                # Check if all replicas are running
                                EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                                echo "Expected replicas: \$EXPECTED_REPLICAS"

                                MAX_WAIT=180
                                ELAPSED=0

                                while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                    RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")
                                    echo "Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS (elapsed: \${ELAPSED}s)"

                                    if [ \$RUNNING_REPLICAS -ge \$EXPECTED_REPLICAS ]; then
                                        echo "✅ All replicas are running - first deployment successful!"
                                        break
                                    fi

                                    sleep 10
                                    ELAPSED=\$((ELAPSED + 10))
                                done

                                if [ \$RUNNING_REPLICAS -lt \$EXPECTED_REPLICAS ]; then
                                    echo "❌ Not all replicas started in time"
                                    docker service logs --tail 50 \$SERVICE_NAME || true
                                    exit 1
                                fi

                            else
                                echo "=========================================="
                                echo "✓ Service exists - Performing Rolling Update"
                                echo "Service name: \$SERVICE_NAME"
                                echo "=========================================="

                                # Save old image for rollback
                                OLD_IMAGE=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}')
                                echo "Old image: \$OLD_IMAGE"
                                echo "New image: ${IMAGE_NAME}:${IMAGE_TAG}"

                                # Deploy new image with rolling update
                                export IMAGE_TAG=${IMAGE_TAG}
                                docker stack deploy -c docker-compose-swarm-prod.yml ${STACK_NAME_PROD}

                                echo "Docker Swarm is performing rolling update..."
                                echo "Monitoring service update progress..."

                                # Wait for deployment to start
                                sleep 20

                                # Get expected replicas
                                EXPECTED_REPLICAS=\$(docker service inspect \$SERVICE_NAME --format '{{.Spec.Mode.Replicated.Replicas}}')
                                echo "Expected replicas: \$EXPECTED_REPLICAS"

                                # Monitor rolling update
                                MAX_WAIT=300
                                ELAPSED=0
                                UPDATE_COMPLETE=false

                                while [ \$ELAPSED -lt \$MAX_WAIT ]; do
                                    STATUS=\$(docker service inspect \$SERVICE_NAME --format '{{.UpdateStatus.State}}' 2>/dev/null || echo "")
                                    RUNNING_REPLICAS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")

                                    echo "Update status: \${STATUS:-none} | Running replicas: \$RUNNING_REPLICAS/\$EXPECTED_REPLICAS | Elapsed: \${ELAPSED}s"

                                    # Check if update completed
                                    if [ "\$STATUS" = "completed" ]; then
                                        echo "✅ Rolling update completed successfully!"
                                        UPDATE_COMPLETE=true
                                        break
                                    # Check if all replicas are running (even if status is unknown)
                                    elif [ \$RUNNING_REPLICAS -ge \$EXPECTED_REPLICAS ] && [ \$ELAPSED -gt 30 ]; then
                                        echo "✅ All replicas running - deployment successful!"
                                        UPDATE_COMPLETE=true
                                        break
                                    # Check for failures
                                    elif [ "\$STATUS" = "rollback_completed" ]; then
                                        echo "❌ Swarm automatic rollback completed!"
                                        echo "Checking service logs..."
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        exit 1
                                    elif [ "\$STATUS" = "paused" ]; then
                                        echo "❌ Update paused - rolling back manually to \$OLD_IMAGE..."
                                        docker service update --image \$OLD_IMAGE \$SERVICE_NAME
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        exit 1
                                    fi

                                    # Show current replicas status
                                    docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" 2>/dev/null || true

                                    sleep 10
                                    ELAPSED=\$((ELAPSED + 10))
                                done

                                # Handle timeout
                                if [ "\$UPDATE_COMPLETE" = "false" ]; then
                                    echo "⚠️ Rolling update timed out. Checking final status..."
                                    FINAL_RUNNING=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")

                                    if [ \$FINAL_RUNNING -ge \$EXPECTED_REPLICAS ]; then
                                        echo "✅ All replicas confirmed running - deployment successful!"
                                        UPDATE_COMPLETE=true
                                    else
                                        echo "❌ Not all replicas running. Rolling back to \$OLD_IMAGE..."
                                        docker service update --image \$OLD_IMAGE \$SERVICE_NAME
                                        echo "Waiting for rollback to complete..."
                                        sleep 20
                                        docker service logs --tail 50 \$SERVICE_NAME || true
                                        docker service ps \$SERVICE_NAME || true
                                        exit 1
                                    fi
                                fi
                            fi

                            echo "=========================================="
                            echo "Production deployment completed successfully!"
                            echo "All replicas running version ${IMAGE_TAG}"
                            echo "=========================================="

                            # Final status
                            docker stack services ${STACK_NAME_PROD}
                            docker stack ps ${STACK_NAME_PROD}

                            # Health Check Status
                            echo ""
                            echo "=========================================="
                            echo "HEALTH CHECK STATUS - PRODUCTION"
                            echo "=========================================="

                            # Get service name
                            SERVICE_NAME=\$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --filter "name=${STACK_NAME_PROD}_lmsbooks_query" --format "{{.Name}}")

                            if [ -n "\$SERVICE_NAME" ]; then
                                echo ""
                                echo "Service: \$SERVICE_NAME"
                                echo "----------------------------------------"

                                # Get all task IDs for the service
                                TASK_IDS=\$(docker service ps \$SERVICE_NAME --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)

                                for TASK_ID in \$TASK_IDS; do
                                    # Get container ID from task
                                    CONTAINER_ID=\$(docker inspect \$TASK_ID --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")

                                    if [ -n "\$CONTAINER_ID" ]; then
                                        echo ""
                                        echo "Task: \$TASK_ID"
                                        HEALTH_STATUS=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "no healthcheck")

                                        if [ "\$HEALTH_STATUS" != "no healthcheck" ]; then
                                            echo "  Health Status: \$HEALTH_STATUS"

                                            # Get last health check log
                                            LAST_CHECK=\$(docker inspect \$CONTAINER_ID --format "{{range .State.Health.Log}}{{.End}} - {{.ExitCode}} - {{.Output}}{{end}}" 2>/dev/null | tail -1 || echo "N/A")
                                            echo "  Last Check: \$LAST_CHECK"
                                        else
                                            echo "  Health Status: Not configured or starting"
                                        fi

                                        # Show replica state
                                        REPLICA_STATE=\$(docker service ps \$SERVICE_NAME --filter "id=\$TASK_ID" --format "{{.CurrentState}}" 2>/dev/null)
                                        echo "  Replica State: \$REPLICA_STATE"
                                    fi
                                done

                                echo ""
                                echo "----------------------------------------"
                                echo "Health Check Configuration:"
                                docker service inspect \$SERVICE_NAME --format "{{json .Spec.TaskTemplate.ContainerSpec.Healthcheck}}" 2>/dev/null | python3 -m json.tool 2>/dev/null || echo "  Configured in docker-compose file"
                            fi

                            # Check health of all services in the stack
                            echo ""
                            echo "=========================================="
                            echo "ALL SERVICES HEALTH STATUS"
                            echo "=========================================="
                            docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

                            echo ""
                            echo "Detailed service inspection:"
                            for SERVICE in \$(docker service ls --filter "label=com.docker.stack.namespace=${STACK_NAME_PROD}" --format "{{.Name}}"); do
                                echo ""
                                echo "Service: \$SERVICE"
                                docker service ps \$SERVICE --format "  {{.Name}}: {{.CurrentState}}" | head -5
                            done

                            echo ""
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Post-Deployment Verification') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                script {
                    def stackName = params.ENVIRONMENT == 'dev' ? env.STACK_NAME_DEV :
                                   (params.ENVIRONMENT == 'staging' ? env.STACK_NAME_STAGING : env.STACK_NAME_PROD)

                    sh """
                        echo "=========================================="
                        echo "POST-DEPLOYMENT VERIFICATION"
                        echo "Environment: ${params.ENVIRONMENT}"
                        echo "=========================================="

                        # Wait for Docker Swarm to update replica status
                        echo ""
                        echo "Waiting 15 seconds for Docker Swarm to update replica status..."
                        sleep 15

                        echo ""
                        echo "Current service status:"
                        docker stack services ${stackName}

                        echo ""
                        echo "Service tasks:"
                        docker stack ps ${stackName} --no-trunc

                        echo ""
                        echo "=========================================="
                    """

                    // Show health checks for production only
                    if (params.ENVIRONMENT == 'prod') {
                        sh """
                            echo ""
                            echo "=========================================="
                            echo "POST-DEPLOYMENT HEALTH CHECK VERIFICATION"
                            echo "==========================================""

                            # Wait a bit for health checks to stabilize
                            echo "Waiting 30 seconds for health checks to stabilize..."
                            sleep 30

                            # Check each service
                            for SERVICE in \$(docker service ls --filter "label=com.docker.stack.namespace=${stackName}" --format "{{.Name}}"); do
                                echo ""
                                echo "Checking health of: \$SERVICE"
                                echo "----------------------------------------"

                                # Get task IDs
                                TASKS=\$(docker service ps \$SERVICE --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null)

                                for TASK in \$TASKS; do
                                    CONTAINER_ID=\$(docker inspect \$TASK --format "{{.Status.ContainerStatus.ContainerID}}" 2>/dev/null || echo "")

                                    if [ -n "\$CONTAINER_ID" ]; then
                                        HEALTH=\$(docker inspect \$CONTAINER_ID --format "{{.State.Health.Status}}" 2>/dev/null || echo "none")
                                        TASK_NAME=\$(docker inspect \$TASK --format "{{.Name}}" 2>/dev/null)

                                        if [ "\$HEALTH" = "healthy" ]; then
                                            echo "  ✅ \$TASK_NAME: HEALTHY"
                                        elif [ "\$HEALTH" = "unhealthy" ]; then
                                            echo "  ❌ \$TASK_NAME: UNHEALTHY"
                                        elif [ "\$HEALTH" = "starting" ]; then
                                            echo "  🔄 \$TASK_NAME: STARTING (health checks in progress)"
                                        else
                                            echo "  ℹ️  \$TASK_NAME: No health check configured"
                                        fi
                                    fi
                                done
                            done

                            echo ""
                            echo "=========================================="
                            echo "✅ Post-deployment verification completed"
                            echo "=========================================="
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                echo "=========================================="
                echo "Pipeline completed successfully!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "Image: ${IMAGE_NAME}:${IMAGE_TAG}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "SUCCESS: LMS Books Query - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Successful</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Image Tag:</strong> ${IMAGE_TAG}</p>
                            <p><strong>Status:</strong> ✅ SUCCESS</p>
                            <br>
                            <p><a href="${BUILD_URL}">View Build Details</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "✅ Success notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "⚠️ WARNING: Could not send success email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }

        failure {
            script {
                echo "=========================================="
                echo "Pipeline failed!"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "=========================================="

                try {
                    emailext(
                        subject: "FAILURE: LMS Books Query - ${params.ENVIRONMENT} - Build #${BUILD_NUMBER}",
                        body: """
                            <h2>Build Failed</h2>
                            <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                            <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                            <p><strong>Status:</strong> ❌ FAILURE</p>
                            <br>
                            <p><a href="${BUILD_URL}console">View Console Output</a></p>
                        """,
                        to: "${EMAIL_RECIPIENT}",
                        mimeType: 'text/html'
                    )
                    echo "✅ Failure notification email sent to ${EMAIL_RECIPIENT}"
                } catch (Exception e) {
                    echo "⚠️ WARNING: Could not send failure email notification"
                    echo "Email error: ${e.message}"
                }
            }
        }
    }
}
